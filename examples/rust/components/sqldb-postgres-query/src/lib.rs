wit_bindgen::generate!({ generate_all });

// NOTE: the imports below is generated by wit_bindgen::generate, due to the
// WIT definition(s) specified in `wit`
use wasmcloud::postgres::query::query;
use wasmcloud::postgres::types::{PgValue, ResultRow, ResultRowEntry};

// NOTE: the `Guest` trait corresponds to the export of the `invoke` interface,
// namespaced to the current WIT namespace & package ("wasmcloud:examples")
use exports::wasmcloud::examples::invoke::Guest;

/// This struct must implement the all `export`ed functionality
/// in the WIT definition (see `wit/component.wit`)
struct QueryRunner;

const CREATE_TABLE_QUERY: &str = r#"
CREATE TABLE IF NOT EXISTS example (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  description text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT NOW()
);
"#;

/// A basic insert query, using Postgres `RETURNING` syntax,
/// which returns the contents of the row that was inserted
const INSERT_QUERY: &str = r#"
INSERT INTO example (description) VALUES ($1) RETURNING *;
"#;

/// A SELECT query, which takes the ID insert query, using Postgres `RETURNING` syntax,
/// which returns the contents of the row that was inserted
const SELECT_QUERY: &str = r#"
SELECT description FROM example WHERE id = $1;
"#;

impl Guest for QueryRunner {
    fn call() -> String {
        // First, ensure the right table is present
        if let Err(e) = query(CREATE_TABLE_QUERY, &[]) {
            return format!("ERROR - failed to create table: {e}");
        };

        // Insert a row into the example
        //
        // NOTE: Details of *which* database against which the query is made are
        // managed by the link between this component and it's provider
        let inserted_row: Vec<ResultRow> = match query(
            INSERT_QUERY,
            &[PgValue::Text("inserted example row!".into())],
        ) {
            // We expect to get just one row, since we're searching by ID
            Ok(row) if row.len() == 1 => row,
            // If we get any other number of rows, we error
            Ok(rows) => {
                return format!(
                    "ERROR: unexpected number of rows ({}) returned by SELECT",
                    rows.len()
                );
            }
            // If the query failed, return the error
            Err(e) => {
                return format!("ERROR: failed to insert row: {e}");
            }
        };

        // Extract the "id" column's value (a PgValue) from the result row entries,
        // since ResultRow is a Vec<ResultRowEntry>
        let Some(ResultRowEntry { value: id, .. }) = inserted_row
            .first()
            .and_then(|r| r.iter().find(|entry| entry.column_name == "id"))
        else {
            return "ERROR: returned row is missing an id column".into();
        };

        // Do an explicit SELECT for the row we just inserted, using the ID that was returned
        //
        // NOTE: normally you would not need this SELECT, thanks to RETURNING:
        // https://www.postgresql.org/docs/current/dml-returning.html
        match query(SELECT_QUERY, &[id.clone()]) {
            Ok(rows) => format!("SUCCESS: inserted and manually retrieved new row:\n{rows:#?}"),
            Err(e) => format!("ERROR: failed to retrieve inserted row: {e}"),
        }
    }
}

export!(QueryRunner);
