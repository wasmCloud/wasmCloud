use anyhow::{bail, Result};
use bytes::Bytes;
use serde::{Deserialize, Serialize};
use url::Url;

// NOTE: The imports below are generated by wit-bindgen
use crate::bindings::wasi::logging::logging::{log, Level};
use crate::bindings::wasmcloud::messaging::types::BrokerMessage;
use crate::bindings::wasmcloud::task_manager::tasks;
use crate::bindings::wasmcloud::task_manager::types::{LeaseId, Task};
// --- END of wit-bindgen generated imports

use crate::{LOG_CONTEXT, WORKER_ID};

/// Image that can be used by default if no image is provided (wasmcloud logo)
pub const DEFAULT_IMAGE_BYTES: &[u8] = std::include_bytes!("../wasmcloud-logo.jpg");

/// S3 Bucket
type Bucket = String;

/// Key inside an S3 bucket
type Key = String;

#[derive(Debug, Serialize, Deserialize)]
pub struct JobMessage {
    /// ID of the task to look up and attempt to perform
    pub task_id: String,
}

/// Source of an image
#[derive(Debug, Default, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
#[serde(tag = "type")]
pub enum ImagePath {
    /// Use the default image for this component
    #[default]
    DefaultImage,
    /// Indicates bytes that were attached (normally to a [`ImageProcessingRequest`])
    Attached,
    /// Remote image stored at a given URL
    RemoteHttps { url: Url },
    /// A previously uploaded file will have a Url that is specific to S3
    /// which we have to retrieve
    ///
    /// We expect this to come in as urls like `s3://<bucket>/<key>?link_name=<link name>`
    Blobstore { path: BlobstorePath },
}

/// Information necessary to direct an upload or download from a blobstore
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct BlobstorePath {
    pub(crate) bucket: Bucket,
    pub(crate) key: Key,
}

/// Operations that can be done on the image
#[derive(Debug, Clone, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
#[serde(tag = "type")]
pub enum ImageOperation {
    /// Perform no changes on the image
    #[default]
    NoOp,
    /// Run a grayscale filter on the image
    Grayscale,
    /// Resize the image with
    Resize { height_px: u32, width_px: u32 },
}

/// Image processing
#[derive(Debug, Serialize, Deserialize)]
pub struct ImageProcessingRequest {
    /// Source of the image
    pub(crate) source: ImagePath,
    /// Destination of the image
    pub(crate) destination: ImagePath,
    /// Format of the image
    pub(crate) image_format: Option<String>,
    /// Operations to perform on the image
    pub(crate) operations: Vec<ImageOperation>,
    /// Image data
    ///
    /// This *may* be empty in the case that the image source is remote and has not been fetched yet
    #[serde(skip)]
    pub(crate) image_data: Option<Bytes>,
}

impl ImageProcessingRequest {
    /// Parse a processing request from a task submitted via a message broker
    pub(crate) fn from_task_msg(msg: &BrokerMessage) -> Result<(Self, Task, LeaseId)> {
        let BrokerMessage { body, .. } = msg;
        // Parse the job message out of the incoming queue message
        let JobMessage { task_id } = match serde_json::from_slice(body) {
            Ok(jm) => jm,
            Err(e) => {
                log(
                    Level::Error,
                    LOG_CONTEXT,
                    &format!("failed to parse job message: {e}"),
                );
                bail!("failed to parse job message");
            }
        };

        // Attempt to lease the task
        let lease_id = match tasks::lease_task(&task_id, &WORKER_ID.into()) {
            Ok(lid) => lid,
            Err(e) => {
                log(
                    Level::Error,
                    LOG_CONTEXT,
                    &format!("failed to lease task: {e}"),
                );
                bail!("failed to lease task");
            }
        };

        // Retrieve the task from object storage
        let task = match tasks::get_task(&task_id) {
            Ok(lid) => lid,
            Err(e) => {
                log(
                    Level::Error,
                    LOG_CONTEXT,
                    &format!("failed to retrieve task: {e}"),
                );
                bail!("failed to retrieve task");
            }
        };

        let Some(ref task_json) = task.data_json else {
            log(
                Level::Error,
                LOG_CONTEXT,
                "task missing data_json internally",
            );
            bail!("task missing data");
        };

        // Parse out the image processing request
        let ipr: ImageProcessingRequest = match serde_json::from_slice(task_json.as_bytes()) {
            Ok(ipr) => ipr,
            Err(e) => {
                log(
                    Level::Error,
                    LOG_CONTEXT,
                    &format!("parse image processing request: {e}"),
                );
                bail!("failed to parse image processing request");
            }
        };

        Ok((ipr, task, lease_id))
    }
}
