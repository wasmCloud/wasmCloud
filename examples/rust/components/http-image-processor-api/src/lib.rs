//! WebAssembly component which functions as an image processor that works over HTTP
//!
//! This library contains the implementation of the "component" world, which looks like the following:
//!
//! ```
//! world component {
//!   import wasi:logging/logging;
//!   import wasi:blobstore/blobstore@0.2.0-draft;
//!   import wasi:http/outgoing-handler@0.2.0;
//!
//!   import wasmcloud:bus/lattice@1.0.0;
//!
//!   export wasi:http/incoming-handler@0.2.0;
//! }
//! ```
//!
//! Using the exports imported functionality, this component:
//!
//! - Takes in HTTP requests (`wasi:http/incoming-handler` export)
//! - Extracts instructions from the HTTP request
//! - Reads or pulls an image from provided source, possibly remote (`wasi:blobstore/blobstore`, `wasi:http/outgoing-handler` imports)
//! - Performs transformations on the given image
//! - Uploads the transformed image to a provided source, possibly remote (`wasi:blobstore/blobstore` import)
//! - Returns the transformed image over HTTP
//!
//!

use std::collections::HashMap;

use anyhow::{anyhow, bail, ensure, Result};
use bytes::{Bytes, BytesMut};
use image::ImageFormat;

mod processing;
use processing::{transform_image, BlobstorePath, ImageProcessingRequest};

mod http;
use http::ToHttpHeader;

mod objstore;

wit_bindgen::generate!({ generate_all });

// NOTE: The imports below are generated by wit-bindgen
use exports::wasi::http::incoming_handler::Guest;
use wasi::blobstore::blobstore;
use wasi::http::types::{
    Fields, IncomingBody, IncomingRequest, Method, OutgoingBody, OutgoingResponse, ResponseOutparam,
};
use wasi::io::streams::StreamError;
use wasi::logging::logging::{log, Level};
// --- END of wit-bindgen generated imports

/// Maximum bytes to write at a time, due to the limitations on wasi-io's blocking_write_and_flush()
const MAX_WRITE_BYTES: usize = 4096;

/// Maximum bytes to read at a time from the incoming request body
/// this value is chosen somewhat arbitrarily, and is not a limit for bytes read,
/// but is instead the amount of bytes to be read *at once*
const MAX_READ_BYTES: usize = 2048;

/// This context is printed in every log message by this component
const LOG_CONTEXT: &str = "http-image-processor-api";

/// Implementation of the world ('component') is attached to this struct
struct ApiServerComponent;

impl Guest for ApiServerComponent {
    /// Handle incoming HTTP requests
    fn handle(request: IncomingRequest, response_out: ResponseOutparam) {
        // Ensure we receive a POST request
        if !matches!(request.method(), Method::Post) {
            if let Err(e) =
                send_error_response(400, "Invalid request method, must be POST", response_out)
            {
                log(
                    Level::Error,
                    LOG_CONTEXT,
                    &format!("failed to send error response: {e}"),
                );
                panic!("failed to send error response");
            }
            return;
        }

        // Decode path and query params
        let path_with_query = request.path_with_query();
        let (path, _) = path_with_query
            .as_deref()
            .unwrap_or("/")
            .split_once('?')
            .unwrap_or(("/", ""));

        // Ensure the path is /process
        if path != "/process" {
            if let Err(e) = send_error_response(
                400,
                &format!("unexpected path [{path}], only /process is allowed"),
                response_out,
            ) {
                log(
                    Level::Error,
                    LOG_CONTEXT,
                    &format!("failed to send error response: {e}"),
                );
                panic!("failed to send error response");
            }
            return;
        }

        // Parse all the parts of the request to find operations
        let image_processing_request = match ImageProcessingRequest::from_incoming_request(request)
        {
            Ok(ipr) => ipr,
            Err(e) => {
                if let Err(e) = send_error_response(
                    500,
                    &format!("failed to build processing request from HTTP request: {e}"),
                    response_out,
                ) {
                    log(
                        Level::Error,
                        LOG_CONTEXT,
                        &format!("failed to build processing request: {e}"),
                    );
                    panic!("failed to send error response");
                }
                return;
            }
        };

        // Download the source image
        let image_bytes = match image_processing_request.fetch_image() {
            Ok(bytes) => bytes,
            Err(e) => {
                if let Err(e) = send_error_response(
                    500,
                    &format!("failed to fetch image bytes: {e}"),
                    response_out,
                ) {
                    log(
                        Level::Error,
                        LOG_CONTEXT,
                        &format!("failed to send error response: {e}"),
                    );
                    panic!("failed to send error response");
                }
                return;
            }
        };

        // Upload the original image output to S3
        if let Err(e) = upload_to_blobstore(
            image_processing_request.blobstore_upload_original,
            image_bytes.clone(),
        ) {
            log(
                Level::Warn,
                LOG_CONTEXT,
                &format!("blobstore upload failed: {e}"),
            )
        };

        // Perform the transformations on the image
        let output_image = match transform_image(
            image_processing_request.image_format,
            image_bytes,
            image_processing_request.operations,
        ) {
            Ok(bytes) => bytes,
            Err(e) => {
                if let Err(e) = send_error_response(
                    500,
                    &format!("failed to perform image transformation: {e}"),
                    response_out,
                ) {
                    log(
                        Level::Error,
                        LOG_CONTEXT,
                        &format!("failed to send error response: {e}"),
                    );
                    panic!("failed to send error response");
                }
                return;
            }
        };
        let output_bytes = Bytes::from(output_image.into_bytes());

        // Upload the transformed image output to S3
        if let Err(e) = upload_to_blobstore(
            image_processing_request.blobstore_upload_output,
            output_bytes.clone(),
        ) {
            log(
                Level::Warn,
                LOG_CONTEXT,
                &format!("blobstore upload failed: {e}"),
            )
        };

        // Send HTTP response with image content
        send_image_response(
            image_processing_request.image_format,
            output_bytes,
            response_out,
        );
    }
}

/// Upload some bytes to a blobstore
fn upload_to_blobstore(path: Option<BlobstorePath>, bytes: Bytes) -> Result<()> {
    let Some(BlobstorePath {
        bucket,
        key,
        link_name,
    }) = path
    else {
        bail!("unexpected image path format (not a blobstore object)");
    };

    if let Err(e) = objstore::write_object(bytes, &link_name, &bucket, &key) {
        log(
            Level::Error,
            LOG_CONTEXT,
            &format!("failed to upload image bytes to object storage: {e}"),
        );
    }

    Ok(())
}

/// Build and send a 200 OK HTTP response with bytes of an image
fn send_image_response(
    image_format: Option<ImageFormat>,
    image_bytes: Bytes,
    response_out: ResponseOutparam,
) {
    let headers = Fields::new();
    if let Some(format) = image_format {
        let (key, value) = format.to_header();
        if let Err(e) = headers.set(&String::from(key), &[value.as_bytes().into()]) {
            if let Err(e) = send_error_response(
                500,
                &format!("failed to set content-type header on response: {e}"),
                response_out,
            ) {
                log(
                    Level::Error,
                    LOG_CONTEXT,
                    &format!("failed to send error response: {e}"),
                );
                panic!("failed to send error response");
            }
            return;
        }
    }

    let response = OutgoingResponse::new(headers);

    if let Err(()) = response.set_status_code(200) {
        if let Err(e) = send_error_response(500, "failed to set status code", response_out) {
            log(
                Level::Error,
                LOG_CONTEXT,
                &format!("failed to send error response: {e}"),
            );
            panic!("failed to send error response");
        }
        return;
    }

    let Ok(response_body) = response.body() else {
        if let Err(e) = send_error_response(
            500,
            "failed to read output stream body while sending image response",
            response_out,
        ) {
            log(
                Level::Error,
                LOG_CONTEXT,
                &format!("failed to send error response: {e}"),
            );
            panic!("failed to send error response");
        }
        return;
    };

    let Ok(stream) = response_body.write() else {
        if let Err(e) = send_error_response(
            500,
            "failed to get output stream from body while sending image response",
            response_out,
        ) {
            log(
                Level::Error,
                LOG_CONTEXT,
                &format!("failed to send error response: {e}"),
            );
            panic!("failed to send error response");
        }
        return;
    };

    // Write the image bytes to the output stream
    for chunk in image_bytes.chunks(MAX_WRITE_BYTES) {
        if let Err(e) = stream
            .blocking_write_and_flush(chunk)
            .map_err(|e| anyhow!("failed to write chunk: {e}"))
        {
            if let Err(e) = send_error_response(
                500,
                &format!("failed write image chunk to output stream: {e}"),
                response_out,
            ) {
                log(
                    Level::Error,
                    LOG_CONTEXT,
                    &format!("failed to send error response: {e}"),
                );
                panic!("failed to send error response");
            }
            return;
        }
    }
    ResponseOutparam::set(response_out, Ok(response));
    OutgoingBody::finish(response_body, None).expect("failed to finish response body");
}

/// Build and send an error response using the WASI HTTP `ResponseOutparam`
fn send_error_response(status: u16, msg: &str, response_out: ResponseOutparam) -> Result<()> {
    let mut bytes = msg.as_bytes();
    if bytes.len() > 4096 {
        log(
            Level::Error,
            LOG_CONTEXT,
            &format!(
                "invalid error response length, {} bytes is too long for blocking-write-and-flush",
                bytes.len()
            ),
        );
        bytes = b"ERROR: see logs for details";
    }

    let response = OutgoingResponse::new(Fields::new());
    response
        .set_status_code(status)
        .map_err(|()| anyhow!("failed to set status code while sending error response"))?;
    let response_body = response
        .body()
        .map_err(|()| anyhow!("failed to get response body"))?;
    ResponseOutparam::set(response_out, Ok(response));
    response_body
        .write()
        .unwrap()
        .blocking_write_and_flush(bytes)
        .map_err(|e| anyhow!("failed to write and flush error body: {e}"))?;
    OutgoingBody::finish(response_body, None)
        .map_err(|e| anyhow!("failed to finish response body (status code {e})"))?;

    Ok(())
}

/// Extract HTTP headers from
fn extract_headers(req: &IncomingRequest) -> HashMap<String, Vec<String>> {
    let mut headers = HashMap::new();
    for (k, v) in req.headers().entries().into_iter() {
        match String::from_utf8(v) {
            Ok(v) => {
                headers
                    .entry(k)
                    .and_modify(|vs: &mut Vec<String>| vs.push(v.clone()))
                    .or_insert(vec![v.clone()]);
            }
            Err(e) => {
                log(
                    Level::Warn,
                    LOG_CONTEXT,
                    &format!("failed to parse value for header key [{k}] into string: {e}"),
                );
            }
        }
    }
    headers
}

// NOTE: Since wit-bindgen makes `IncomingRequest` available to us as a local type,
// we can add convenience functions to it
impl IncomingRequest {
    /// Check if the incoming request body has the `multipart/form-data` content type
    fn is_multipart_formdata(&self) -> bool {
        self.headers()
            .entries()
            .iter()
            .find(|(k, _v)| k.to_lowercase() == "content-type")
            .is_some_and(|(_k, v)| String::from_utf8_lossy(v).contains("multipart/form-data"))
    }

    /// Check if the incoming request body has the `application/json` content type
    fn is_json(&self) -> bool {
        self.headers()
            .entries()
            .iter()
            .find(|(k, _v)| k.to_lowercase() == "content-type")
            .is_some_and(|(_k, v)| String::from_utf8_lossy(v).contains("application/json"))
    }

    /// This is a convenience function that extracts out the body of a IncomingRequest
    fn read_body(self) -> Result<Bytes> {
        let incoming_req_body = self
            .consume()
            .map_err(|()| anyhow!("failed to consume incoming request body"))?;
        let incoming_req_body_stream = incoming_req_body
            .stream()
            .map_err(|()| anyhow!("failed to build stream for incoming request body"))?;
        let mut buf = BytesMut::with_capacity(MAX_READ_BYTES);
        loop {
            match incoming_req_body_stream.read(MAX_READ_BYTES as u64) {
                Ok(bytes) if bytes.is_empty() => break,
                Ok(bytes) => {
                    ensure!(
                        bytes.len() <= MAX_READ_BYTES,
                        "read more bytes than requested"
                    );
                    buf.extend(bytes);
                }
                Err(StreamError::Closed) => break,
                Err(e) => bail!("failed to read bytes: {e}"),
            }
        }
        drop(incoming_req_body_stream);
        IncomingBody::finish(incoming_req_body);
        Ok(buf.freeze())
    }
}

export!(ApiServerComponent);
