//! WebAssembly component which functions as an image processor that works over HTTP
//!
//! This library contains the implementation of the "component" world, which looks like the following:
//!
//! ```
//! world component {
//!   import wasi:logging/logging;
//!   import wasi:blobstore/blobstore@0.2.0-draft;
//!   import wasi:http/outgoing-handler@0.2.0;
//!
//!   import wasmcloud:bus/lattice@1.0.0;
//!
//!   export wasi:http/incoming-handler@0.2.0;
//! }
//! ```
//!
//! Using the exports imported functionality, this component:
//!
//! - Takes in HTTP requests (`wasi:http/incoming-handler` export)
//! - Extracts instructions from the HTTP request
//! - Reads or pulls an image from provided source, possibly remote (`wasi:blobstore/blobstore`, `wasi:http/outgoing-handler` imports)
//! - Performs transformations on the given image
//! - Uploads the transformed image to a provided source, possibly remote (`wasi:blobstore/blobstore` import)
//! - Returns the transformed image over HTTP
//!
//!

use anyhow::{anyhow, bail, ensure, Result};
use bytes::{Bytes, BytesMut};
use serde_json::json;
use uuid::Uuid;

mod bindings {
    //! These bindings are generated by wit-bindgen, and reused by other parts of the crate
    use crate::ApiServerComponent;

    wit_bindgen::generate!({ generate_all });

    export!(ApiServerComponent);
}

// NOTE: The imports below are generated by wit-bindgen
use bindings::exports::wasi::http::incoming_handler::Guest;
use bindings::wasi::blobstore::blobstore;
use bindings::wasi::config::runtime as runtime_config;
use bindings::wasi::http::types::{
    Fields, IncomingBody, IncomingRequest, Method, OutgoingBody, OutgoingResponse, ResponseOutparam,
};
use bindings::wasi::io::streams::StreamError;
use bindings::wasi::logging::logging::{log, Level};
use bindings::wasmcloud::messaging::consumer;
use bindings::wasmcloud::messaging::types::BrokerMessage;
use bindings::wasmcloud::task_manager::tasks;
use bindings::wasmcloud::task_manager::types::TaskStatus;
// --- END of wit-bindgen generated imports

mod processing;
use processing::{
    transform_image, BlobstorePath, ImageOperation, ImagePath, ImageProcessingRequest,
};

mod http;
use http::{send_error_response, send_image_response, send_response_json, try_send_error};

mod objstore;
use objstore::{read_object, write_object};

/// Maximum bytes to write at a time, due to the limitations on wasi-io's blocking_write_and_flush()
const MAX_WRITE_BYTES: usize = 4096;

/// Maximum bytes to read at a time from the incoming request body
/// this value is chosen somewhat arbitrarily, and is not a limit for bytes read,
/// but is instead the amount of bytes to be read *at once*
const MAX_READ_BYTES: usize = 2048;

/// This context is printed in every log message by this component
const LOG_CONTEXT: &str = "http-image-processor-api";

const TASK_GROUP_ID: &str = "image-processing";

/// Implementation of the world ('component') is attached to this struct
struct ApiServerComponent;

impl Guest for ApiServerComponent {
    /// Handle incoming HTTP requests
    fn handle(request: IncomingRequest, response_out: ResponseOutparam) {
        let method = request.method();
        let path_with_query = request.path_with_query();
        let (path, _) = path_with_query
            .as_deref()
            .unwrap_or("/")
            .split_once('?')
            .unwrap_or(("/", ""));

        // Route the HTTP requests
        match (method, path) {
            // GET /ready
            //
            // Simple endpoint to indicate this component's information/when it's ready to be used
            // this is another thing.
            (Method::Get, "/ready") => {
                send_response_json(response_out, json!({"status": "success" }), 200);
            }

            // POST /api/v1/jobs/image-processing
            //
            // Submit a job that represents an image to be processed, possibly including
            // sending the image along with the request as multipart form data.
            (Method::Post, "/api/v1/jobs/image-processing") => {
                let worker_topic = match runtime_config::get("worker-topic") {
                    Ok(Some(wt)) => wt,
                    _ => {
                        log(
                            Level::Error,
                            LOG_CONTEXT,
                            &format!("failed to find configuration [worker-topic]"),
                        );
                        try_send_error!(
                            LOG_CONTEXT,
                            500,
                            "missing-config",
                            "missing configuration for worker topic",
                            response_out
                        );
                        return;
                    }
                };
                let upload_bucket = match runtime_config::get("upload_bucket") {
                    Ok(Some(wt)) => wt,
                    _ => {
                        log(
                            Level::Error,
                            LOG_CONTEXT,
                            &format!("failed to find configuration [upload-bucket]"),
                        );
                        try_send_error!(
                            LOG_CONTEXT,
                            500,
                            "missing-config",
                            "missing configuration for upload bucket",
                            response_out
                        );
                        return;
                    }
                };
                let upload_key = match runtime_config::get("upload_key") {
                    Ok(Some(wt)) => wt,
                    _ => {
                        log(
                            Level::Error,
                            LOG_CONTEXT,
                            &format!("failed to find configuration [upload-key]"),
                        );
                        try_send_error!(
                            LOG_CONTEXT,
                            500,
                            "missing-config",
                            "missing configuration for upload key",
                            response_out
                        );
                        return;
                    }
                };

                // Turn the incoming HTTP request into a processing request
                let ipr = match ImageProcessingRequest::from_incoming_request(request) {
                    Ok(ipr) => ipr,
                    Err(e) => {
                        log(
                            Level::Error,
                            LOG_CONTEXT,
                            &format!("failed to process incoming image request: {e}"),
                        );
                        try_send_error!(
                            LOG_CONTEXT,
                            400,
                            "bad-request",
                            "failed to process incoming image processing request",
                            response_out
                        );
                        return;
                    }
                };

                // Upload image data to blobstore if it was uploaded
                if let Some(image_data) = ipr.image_data {
                    // Upload the image to object storage
                    if let Err(e) = write_object(image_data, &upload_bucket, &upload_key) {
                        log(
                            Level::Error,
                            LOG_CONTEXT,
                            &format!("failed to write object to storage: {e}"),
                        );
                        try_send_error!(
                            LOG_CONTEXT,
                            500,
                            "storage-error",
                            "failed to store image in blobstorage",
                            response_out
                        );
                        return;
                    };
                }

                // Submit a processing task to the task manager
                let task = match tasks::submit_task(
                    TASK_GROUP_ID.into(),
                    &json!({
                        "req": ImageProcessingRequest {
                            image_source: ImagePath::Blobstore{ path: BlobstorePath {
                                bucket: upload_bucket.into(),
                                key: upload_key.into(),
                            }},
                            image_format: None,
                            operations: vec![
                                // TODO: read operations from request/URL
                                ImageOperation::Grayscale,
                            ],
                            image_data: None,
                        },
                    })
                    .to_string(),
                ) {
                    Ok(t) => t,
                    Err(e) => {
                        log(
                            Level::Error,
                            LOG_CONTEXT,
                            &format!("failed to submit task: {e}"),
                        );
                        try_send_error!(
                            LOG_CONTEXT,
                            500,
                            "task-submission-error",
                            "failed to submit new work task",
                            response_out
                        );
                        return;
                    }
                };

                // Send a request to start work to the image processor worker
                if let Err(e) = consumer::publish(&BrokerMessage {
                    subject: worker_topic,
                    reply_to: None,
                    body: json!({
                        "task_id": task.id
                    })
                    .to_string()
                    .into_bytes(),
                }) {
                    try_send_error!(
                        LOG_CONTEXT,
                        500,
                        "task-trigger-error",
                        "failed to trigger worker for task",
                        response_out
                    );
                    return;
                }

                // TODO: move this to another component
                //handle_image_process(request, response_out);

                send_response_json(
                    response_out,
                    json!({
                        "status": "success",
                        "data": {
                            "job_id": task.id,
                        }
                    }),
                    200,
                );
            }

            // GET /api/v1/jobs/:job_id/status
            //
            // Get the status of a processing job that has been submitted
            (Method::Get, path)
                if path.starts_with("/api/v1/jobs/") && path.ends_with("/status") =>
            {
                let job_id = match path.split("/").collect::<Vec<&str>>()[..] {
                    [_, _, _, _, jid, _] => jid,
                    _ => {
                        try_send_error!(
                            LOG_CONTEXT,
                            500,
                            "invalid-url",
                            "unexpected URL pattern, missing job_id segment",
                            response_out
                        );
                        return;
                    }
                };

                // Retrieve the task so we can check status
                let task = match tasks::get_task(&String::from(job_id)) {
                    Ok(t) => t,
                    Err(e) => {
                        try_send_error!(
                            LOG_CONTEXT,
                            500,
                            "invalid-task",
                            &format!("failed to get task with ID [{job_id}]"),
                            response_out
                        );
                        return;
                    }
                };

                send_response_json(
                    response_out,
                    json!({
                        "status": "success",
                        "data": task_status_to_string(task.status),
                    }),
                    404,
                );
            }

            // GET /api/v1/jobs/:job_id/output
            //
            // Get the output of a processing job
            (Method::Get, path)
                if path.starts_with("/api/v1/jobs/") && path.ends_with("/output") =>
            {
                let job_id = match path.split("/").collect::<Vec<&str>>()[..] {
                    [_, _, _, _, jid, _] => jid,
                    _ => {
                        try_send_error!(
                            LOG_CONTEXT,
                            500,
                            "invalid-url",
                            "unexpected URL pattern, missing job_id segment",
                            response_out
                        );
                        return;
                    }
                };
                // We can access the bytes for the output image since we know the job name
                let download_bucket = match runtime_config::get("download_bucket") {
                    Ok(Some(wt)) => wt,
                    _ => {
                        log(
                            Level::Error,
                            LOG_CONTEXT,
                            &format!("failed to find configuration [download-bucket]"),
                        );
                        try_send_error!(
                            LOG_CONTEXT,
                            500,
                            "missing-config",
                            "missing configuration for download bucket",
                            response_out
                        );
                        return;
                    }
                };
                let download_key = match runtime_config::get("download_key") {
                    Ok(Some(wt)) => wt,
                    _ => {
                        log(
                            Level::Error,
                            LOG_CONTEXT,
                            &format!("failed to find configuration [download-key]"),
                        );
                        try_send_error!(
                            LOG_CONTEXT,
                            500,
                            "missing-config",
                            "missing configuration for download key",
                            response_out
                        );
                        return;
                    }
                };

                let item_key = format!("{download_key}/{job_id}");

                // Read the object from storage
                //
                // Here, we assume that the uploader and downloader are dealing with the same backing storage
                // so we can access the image's bytes (saved in a different bucket)
                let bytes = match read_object(&download_bucket, &item_key) {
                    Ok(b) => b,
                    Err(e) => {
                        log(
                            Level::Error,
                            LOG_CONTEXT,
                            &format!("failed to find download processed image from [{download_bucket}/{item_key}]"),
                        );
                        try_send_error!(
                            LOG_CONTEXT,
                            500,
                            "storage-error",
                            "failed to download processed image",
                            response_out
                        );
                        return;
                    }
                };

                // TODO: we could signal the format another way (filename, extra metadata on job, etc)
                send_image_response(image::guess_format(&bytes).ok(), bytes, response_out);
            }

            // For all other requests, send a 404 with a JSON body that indicates the invalid endpoint
            _ => send_response_json(
                response_out,
                json!({
                    "status": "error",
                    "error": {
                        "code": "invalid-endpoint",
                        "message": format!("no such endpoint [{path}]"),
                    }
                }),
                404,
            ),
        }
    }
}

// /// Handle the image processing given an incoming HTTP request
// fn handle_image_process(request: IncomingRequest, response_out: ResponseOutparam) {
//     // Parse all the parts of the request to find operations
//     let image_processing_request = match ImageProcessingRequest::from_incoming_request(request) {
//         Ok(ipr) => ipr,
//         Err(e) => {
//             if let Err(e) = send_error_response(
//                 400,
//                 "invalid-request",
//                 &format!("failed to build processing request from HTTP request: {e}"),
//                 response_out,
//             ) {
//                 log(
//                     Level::Error,
//                     LOG_CONTEXT,
//                     &format!("failed to build processing request: {e}"),
//                 );
//                 panic!("failed to send error response");
//             }
//             return;
//         }
//     };

//     // Download the source image
//     let image_bytes = match image_processing_request.fetch_image() {
//         Ok(bytes) => bytes,
//         Err(e) => {
//             if let Err(e) = send_error_response(
//                 400,
//                 "invalid-request",
//                 &format!("failed to fetch image bytes: {e}"),
//                 response_out,
//             ) {
//                 log(
//                     Level::Error,
//                     LOG_CONTEXT,
//                     &format!("failed to send error response: {e}"),
//                 );
//                 panic!("failed to send error response");
//             }
//             return;
//         }
//     };

//     // Upload the original image output to S3
//     if let Err(e) = upload_to_blobstore(
//         image_processing_request.blobstore_upload_original,
//         image_bytes.clone(),
//     ) {
//         log(
//             Level::Warn,
//             LOG_CONTEXT,
//             &format!("blobstore upload failed: {e}"),
//         )
//     };

//     // Perform the transformations on the image
//     let output_image = match transform_image(
//         image_processing_request.image_format,
//         image_bytes,
//         image_processing_request.operations,
//     ) {
//         Ok(bytes) => bytes,
//         Err(e) => {
//             if let Err(e) = send_error_response(
//                 500,
//                 "image-transform-error",
//                 &format!("failed to perform image transformation: {e}"),
//                 response_out,
//             ) {
//                 log(
//                     Level::Error,
//                     LOG_CONTEXT,
//                     &format!("failed to send error response: {e}"),
//                 );
//                 panic!("failed to send error response");
//             }
//             return;
//         }
//     };
//     let output_bytes = Bytes::from(output_image.into_bytes());

//     // Upload the transformed image output to S3
//     if let Err(e) = upload_to_blobstore(
//         image_processing_request.blobstore_upload_output,
//         output_bytes.clone(),
//     ) {
//         log(
//             Level::Warn,
//             LOG_CONTEXT,
//             &format!("blobstore upload failed: {e}"),
//         )
//     };

//     // Send HTTP response with image content
//     send_image_response(
//         image_processing_request.image_format,
//         output_bytes,
//         response_out,
//     );
// }

// /// Upload some bytes to a blobstore
// fn upload_to_blobstore(path: Option<BlobstorePath>, bytes: Bytes) -> Result<()> {
//     let Some(BlobstorePath {
//         bucket,
//         key,
//         link_name,
//     }) = path
//     else {
//         bail!("unexpected image path format (not a blobstore object)");
//     };

//     if let Err(e) = objstore::write_object(bytes, &link_name, &bucket, &key) {
//         log(
//             Level::Error,
//             LOG_CONTEXT,
//             &format!("failed to upload image bytes to object storage: {e}"),
//         );
//     }

//     Ok(())
// }

// NOTE: Since wit-bindgen makes `IncomingRequest` available to us as a local type,
// we can add convenience functions to it
impl IncomingRequest {
    /// Check if the incoming request body has the `multipart/form-data` content type
    fn is_multipart_formdata(&self) -> bool {
        self.headers()
            .entries()
            .iter()
            .find(|(k, _v)| k.to_lowercase() == "content-type")
            .is_some_and(|(_k, v)| String::from_utf8_lossy(v).contains("multipart/form-data"))
    }

    /// Check if the incoming request body has the `application/json` content type
    fn is_json(&self) -> bool {
        self.headers()
            .entries()
            .iter()
            .find(|(k, _v)| k.to_lowercase() == "content-type")
            .is_some_and(|(_k, v)| String::from_utf8_lossy(v).contains("application/json"))
    }

    /// This is a convenience function that extracts out the body of a IncomingRequest
    fn read_body(self) -> Result<Bytes> {
        let incoming_req_body = self
            .consume()
            .map_err(|()| anyhow!("failed to consume incoming request body"))?;
        let incoming_req_body_stream = incoming_req_body
            .stream()
            .map_err(|()| anyhow!("failed to build stream for incoming request body"))?;
        let mut buf = BytesMut::with_capacity(MAX_READ_BYTES);
        loop {
            match incoming_req_body_stream.read(MAX_READ_BYTES as u64) {
                Ok(bytes) if bytes.is_empty() => break,
                Ok(bytes) => {
                    ensure!(
                        bytes.len() <= MAX_READ_BYTES,
                        "read more bytes than requested"
                    );
                    buf.extend(bytes);
                }
                Err(StreamError::Closed) => break,
                Err(e) => bail!("failed to read bytes: {e}"),
            }
        }
        drop(incoming_req_body_stream);
        IncomingBody::finish(incoming_req_body);
        Ok(buf.freeze())
    }
}

fn task_status_to_string(status: TaskStatus) -> &'static str {
    match status {
        TaskStatus::Pending => "pending",
        TaskStatus::Leased => "leased",
        TaskStatus::Completed => "completed",
        TaskStatus::Failed => "failed",
    }
}
