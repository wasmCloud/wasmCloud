// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package types represents the imported interface "wasi:http/types@0.2.0".
//
// This interface defines all of the types and methods for implementing
// HTTP Requests and Responses, both incoming and outgoing, as well as
// their headers, trailers, and bodies.
package types

import (
	"github.com/bytecodealliance/wasm-tools-go/cm"
	monotonicclock "github.com/wasmcloud/wasmcloud/examples/golang/components/http-client-tinygo/gen/wasi/clocks/monotonic-clock"
	ioerror "github.com/wasmcloud/wasmcloud/examples/golang/components/http-client-tinygo/gen/wasi/io/error"
	"github.com/wasmcloud/wasmcloud/examples/golang/components/http-client-tinygo/gen/wasi/io/poll"
	"github.com/wasmcloud/wasmcloud/examples/golang/components/http-client-tinygo/gen/wasi/io/streams"
)

// Duration represents the type alias "wasi:http/types@0.2.0#duration".
//
// See [monotonicclock.Duration] for more information.
type Duration = monotonicclock.Duration

// InputStream represents the imported type alias "wasi:http/types@0.2.0#input-stream".
//
// See [streams.InputStream] for more information.
type InputStream = streams.InputStream

// OutputStream represents the imported type alias "wasi:http/types@0.2.0#output-stream".
//
// See [streams.OutputStream] for more information.
type OutputStream = streams.OutputStream

// IOError represents the imported type alias "wasi:http/types@0.2.0#io-error".
//
// See [ioerror.Error] for more information.
type IOError = ioerror.Error

// Pollable represents the imported type alias "wasi:http/types@0.2.0#pollable".
//
// See [poll.Pollable] for more information.
type Pollable = poll.Pollable

// Method represents the variant "wasi:http/types@0.2.0#method".
//
// This type corresponds to HTTP standard Methods.
//
//	variant method {
//		get,
//		head,
//		post,
//		put,
//		delete,
//		connect,
//		options,
//		trace,
//		patch,
//		other(string),
//	}
type Method cm.Variant[uint8, string, string]

// MethodGet returns a [Method] of case "get".
func MethodGet() Method {
	var data struct{}
	return cm.New[Method](0, data)
}

// Get returns true if [Method] represents the variant case "get".
func (self *Method) Get() bool {
	return self.Tag() == 0
}

// MethodHead returns a [Method] of case "head".
func MethodHead() Method {
	var data struct{}
	return cm.New[Method](1, data)
}

// Head returns true if [Method] represents the variant case "head".
func (self *Method) Head() bool {
	return self.Tag() == 1
}

// MethodPost returns a [Method] of case "post".
func MethodPost() Method {
	var data struct{}
	return cm.New[Method](2, data)
}

// Post returns true if [Method] represents the variant case "post".
func (self *Method) Post() bool {
	return self.Tag() == 2
}

// MethodPut returns a [Method] of case "put".
func MethodPut() Method {
	var data struct{}
	return cm.New[Method](3, data)
}

// Put returns true if [Method] represents the variant case "put".
func (self *Method) Put() bool {
	return self.Tag() == 3
}

// MethodDelete returns a [Method] of case "delete".
func MethodDelete() Method {
	var data struct{}
	return cm.New[Method](4, data)
}

// Delete returns true if [Method] represents the variant case "delete".
func (self *Method) Delete() bool {
	return self.Tag() == 4
}

// MethodConnect returns a [Method] of case "connect".
func MethodConnect() Method {
	var data struct{}
	return cm.New[Method](5, data)
}

// Connect returns true if [Method] represents the variant case "connect".
func (self *Method) Connect() bool {
	return self.Tag() == 5
}

// MethodOptions returns a [Method] of case "options".
func MethodOptions() Method {
	var data struct{}
	return cm.New[Method](6, data)
}

// Options returns true if [Method] represents the variant case "options".
func (self *Method) Options() bool {
	return self.Tag() == 6
}

// MethodTrace returns a [Method] of case "trace".
func MethodTrace() Method {
	var data struct{}
	return cm.New[Method](7, data)
}

// Trace returns true if [Method] represents the variant case "trace".
func (self *Method) Trace() bool {
	return self.Tag() == 7
}

// MethodPatch returns a [Method] of case "patch".
func MethodPatch() Method {
	var data struct{}
	return cm.New[Method](8, data)
}

// Patch returns true if [Method] represents the variant case "patch".
func (self *Method) Patch() bool {
	return self.Tag() == 8
}

// MethodOther returns a [Method] of case "other".
func MethodOther(data string) Method {
	return cm.New[Method](9, data)
}

// Other returns a non-nil *[string] if [Method] represents the variant case "other".
func (self *Method) Other() *string {
	return cm.Case[string](self, 9)
}

var stringsMethod = [10]string{
	"get",
	"head",
	"post",
	"put",
	"delete",
	"connect",
	"options",
	"trace",
	"patch",
	"other",
}

// String implements [fmt.Stringer], returning the variant case name of v.
func (v Method) String() string {
	return stringsMethod[v.Tag()]
}

// Scheme represents the variant "wasi:http/types@0.2.0#scheme".
//
// This type corresponds to HTTP standard Related Schemes.
//
//	variant scheme {
//		HTTP,
//		HTTPS,
//		other(string),
//	}
type Scheme cm.Variant[uint8, string, string]

// SchemeHTTP returns a [Scheme] of case "HTTP".
func SchemeHTTP() Scheme {
	var data struct{}
	return cm.New[Scheme](0, data)
}

// HTTP returns true if [Scheme] represents the variant case "HTTP".
func (self *Scheme) HTTP() bool {
	return self.Tag() == 0
}

// SchemeHTTPS returns a [Scheme] of case "HTTPS".
func SchemeHTTPS() Scheme {
	var data struct{}
	return cm.New[Scheme](1, data)
}

// HTTPS returns true if [Scheme] represents the variant case "HTTPS".
func (self *Scheme) HTTPS() bool {
	return self.Tag() == 1
}

// SchemeOther returns a [Scheme] of case "other".
func SchemeOther(data string) Scheme {
	return cm.New[Scheme](2, data)
}

// Other returns a non-nil *[string] if [Scheme] represents the variant case "other".
func (self *Scheme) Other() *string {
	return cm.Case[string](self, 2)
}

var stringsScheme = [3]string{
	"HTTP",
	"HTTPS",
	"other",
}

// String implements [fmt.Stringer], returning the variant case name of v.
func (v Scheme) String() string {
	return stringsScheme[v.Tag()]
}

// DNSErrorPayload represents the record "wasi:http/types@0.2.0#DNS-error-payload".
//
// Defines the case payload type for `DNS-error` above:
//
//	record DNS-error-payload {
//		rcode: option<string>,
//		info-code: option<u16>,
//	}
type DNSErrorPayload struct {
	_        cm.HostLayout
	Rcode    cm.Option[string]
	InfoCode cm.Option[uint16]
}

// TLSAlertReceivedPayload represents the record "wasi:http/types@0.2.0#TLS-alert-received-payload".
//
// Defines the case payload type for `TLS-alert-received` above:
//
//	record TLS-alert-received-payload {
//		alert-id: option<u8>,
//		alert-message: option<string>,
//	}
type TLSAlertReceivedPayload struct {
	_            cm.HostLayout
	AlertID      cm.Option[uint8]
	AlertMessage cm.Option[string]
}

// FieldSizePayload represents the record "wasi:http/types@0.2.0#field-size-payload".
//
// Defines the case payload type for `HTTP-response-{header,trailer}-size` above:
//
//	record field-size-payload {
//		field-name: option<string>,
//		field-size: option<u32>,
//	}
type FieldSizePayload struct {
	_         cm.HostLayout
	FieldName cm.Option[string]
	FieldSize cm.Option[uint32]
}

// ErrorCode represents the variant "wasi:http/types@0.2.0#error-code".
//
// These cases are inspired by the IANA HTTP Proxy Error Types:
// https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types
//
//	variant error-code {
//		DNS-timeout,
//		DNS-error(DNS-error-payload),
//		destination-not-found,
//		destination-unavailable,
//		destination-IP-prohibited,
//		destination-IP-unroutable,
//		connection-refused,
//		connection-terminated,
//		connection-timeout,
//		connection-read-timeout,
//		connection-write-timeout,
//		connection-limit-reached,
//		TLS-protocol-error,
//		TLS-certificate-error,
//		TLS-alert-received(TLS-alert-received-payload),
//		HTTP-request-denied,
//		HTTP-request-length-required,
//		HTTP-request-body-size(option<u64>),
//		HTTP-request-method-invalid,
//		HTTP-request-URI-invalid,
//		HTTP-request-URI-too-long,
//		HTTP-request-header-section-size(option<u32>),
//		HTTP-request-header-size(option<field-size-payload>),
//		HTTP-request-trailer-section-size(option<u32>),
//		HTTP-request-trailer-size(field-size-payload),
//		HTTP-response-incomplete,
//		HTTP-response-header-section-size(option<u32>),
//		HTTP-response-header-size(field-size-payload),
//		HTTP-response-body-size(option<u64>),
//		HTTP-response-trailer-section-size(option<u32>),
//		HTTP-response-trailer-size(field-size-payload),
//		HTTP-response-transfer-coding(option<string>),
//		HTTP-response-content-coding(option<string>),
//		HTTP-response-timeout,
//		HTTP-upgrade-failed,
//		HTTP-protocol-error,
//		loop-detected,
//		configuration-error,
//		internal-error(option<string>),
//	}
type ErrorCode cm.Variant[uint8, OptionFieldSizePayloadShape, cm.Option[uint64]]

// ErrorCodeDNSTimeout returns a [ErrorCode] of case "DNS-timeout".
func ErrorCodeDNSTimeout() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](0, data)
}

// DNSTimeout returns true if [ErrorCode] represents the variant case "DNS-timeout".
func (self *ErrorCode) DNSTimeout() bool {
	return self.Tag() == 0
}

// ErrorCodeDNSError returns a [ErrorCode] of case "DNS-error".
func ErrorCodeDNSError(data DNSErrorPayload) ErrorCode {
	return cm.New[ErrorCode](1, data)
}

// DNSError returns a non-nil *[DNSErrorPayload] if [ErrorCode] represents the variant case "DNS-error".
func (self *ErrorCode) DNSError() *DNSErrorPayload {
	return cm.Case[DNSErrorPayload](self, 1)
}

// ErrorCodeDestinationNotFound returns a [ErrorCode] of case "destination-not-found".
func ErrorCodeDestinationNotFound() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](2, data)
}

// DestinationNotFound returns true if [ErrorCode] represents the variant case "destination-not-found".
func (self *ErrorCode) DestinationNotFound() bool {
	return self.Tag() == 2
}

// ErrorCodeDestinationUnavailable returns a [ErrorCode] of case "destination-unavailable".
func ErrorCodeDestinationUnavailable() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](3, data)
}

// DestinationUnavailable returns true if [ErrorCode] represents the variant case "destination-unavailable".
func (self *ErrorCode) DestinationUnavailable() bool {
	return self.Tag() == 3
}

// ErrorCodeDestinationIPProhibited returns a [ErrorCode] of case "destination-IP-prohibited".
func ErrorCodeDestinationIPProhibited() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](4, data)
}

// DestinationIPProhibited returns true if [ErrorCode] represents the variant case "destination-IP-prohibited".
func (self *ErrorCode) DestinationIPProhibited() bool {
	return self.Tag() == 4
}

// ErrorCodeDestinationIPUnroutable returns a [ErrorCode] of case "destination-IP-unroutable".
func ErrorCodeDestinationIPUnroutable() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](5, data)
}

// DestinationIPUnroutable returns true if [ErrorCode] represents the variant case "destination-IP-unroutable".
func (self *ErrorCode) DestinationIPUnroutable() bool {
	return self.Tag() == 5
}

// ErrorCodeConnectionRefused returns a [ErrorCode] of case "connection-refused".
func ErrorCodeConnectionRefused() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](6, data)
}

// ConnectionRefused returns true if [ErrorCode] represents the variant case "connection-refused".
func (self *ErrorCode) ConnectionRefused() bool {
	return self.Tag() == 6
}

// ErrorCodeConnectionTerminated returns a [ErrorCode] of case "connection-terminated".
func ErrorCodeConnectionTerminated() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](7, data)
}

// ConnectionTerminated returns true if [ErrorCode] represents the variant case "connection-terminated".
func (self *ErrorCode) ConnectionTerminated() bool {
	return self.Tag() == 7
}

// ErrorCodeConnectionTimeout returns a [ErrorCode] of case "connection-timeout".
func ErrorCodeConnectionTimeout() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](8, data)
}

// ConnectionTimeout returns true if [ErrorCode] represents the variant case "connection-timeout".
func (self *ErrorCode) ConnectionTimeout() bool {
	return self.Tag() == 8
}

// ErrorCodeConnectionReadTimeout returns a [ErrorCode] of case "connection-read-timeout".
func ErrorCodeConnectionReadTimeout() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](9, data)
}

// ConnectionReadTimeout returns true if [ErrorCode] represents the variant case "connection-read-timeout".
func (self *ErrorCode) ConnectionReadTimeout() bool {
	return self.Tag() == 9
}

// ErrorCodeConnectionWriteTimeout returns a [ErrorCode] of case "connection-write-timeout".
func ErrorCodeConnectionWriteTimeout() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](10, data)
}

// ConnectionWriteTimeout returns true if [ErrorCode] represents the variant case "connection-write-timeout".
func (self *ErrorCode) ConnectionWriteTimeout() bool {
	return self.Tag() == 10
}

// ErrorCodeConnectionLimitReached returns a [ErrorCode] of case "connection-limit-reached".
func ErrorCodeConnectionLimitReached() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](11, data)
}

// ConnectionLimitReached returns true if [ErrorCode] represents the variant case "connection-limit-reached".
func (self *ErrorCode) ConnectionLimitReached() bool {
	return self.Tag() == 11
}

// ErrorCodeTLSProtocolError returns a [ErrorCode] of case "TLS-protocol-error".
func ErrorCodeTLSProtocolError() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](12, data)
}

// TLSProtocolError returns true if [ErrorCode] represents the variant case "TLS-protocol-error".
func (self *ErrorCode) TLSProtocolError() bool {
	return self.Tag() == 12
}

// ErrorCodeTLSCertificateError returns a [ErrorCode] of case "TLS-certificate-error".
func ErrorCodeTLSCertificateError() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](13, data)
}

// TLSCertificateError returns true if [ErrorCode] represents the variant case "TLS-certificate-error".
func (self *ErrorCode) TLSCertificateError() bool {
	return self.Tag() == 13
}

// ErrorCodeTLSAlertReceived returns a [ErrorCode] of case "TLS-alert-received".
func ErrorCodeTLSAlertReceived(data TLSAlertReceivedPayload) ErrorCode {
	return cm.New[ErrorCode](14, data)
}

// TLSAlertReceived returns a non-nil *[TLSAlertReceivedPayload] if [ErrorCode] represents the variant case "TLS-alert-received".
func (self *ErrorCode) TLSAlertReceived() *TLSAlertReceivedPayload {
	return cm.Case[TLSAlertReceivedPayload](self, 14)
}

// ErrorCodeHTTPRequestDenied returns a [ErrorCode] of case "HTTP-request-denied".
func ErrorCodeHTTPRequestDenied() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](15, data)
}

// HTTPRequestDenied returns true if [ErrorCode] represents the variant case "HTTP-request-denied".
func (self *ErrorCode) HTTPRequestDenied() bool {
	return self.Tag() == 15
}

// ErrorCodeHTTPRequestLengthRequired returns a [ErrorCode] of case "HTTP-request-length-required".
func ErrorCodeHTTPRequestLengthRequired() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](16, data)
}

// HTTPRequestLengthRequired returns true if [ErrorCode] represents the variant case "HTTP-request-length-required".
func (self *ErrorCode) HTTPRequestLengthRequired() bool {
	return self.Tag() == 16
}

// ErrorCodeHTTPRequestBodySize returns a [ErrorCode] of case "HTTP-request-body-size".
func ErrorCodeHTTPRequestBodySize(data cm.Option[uint64]) ErrorCode {
	return cm.New[ErrorCode](17, data)
}

// HTTPRequestBodySize returns a non-nil *[cm.Option[uint64]] if [ErrorCode] represents the variant case "HTTP-request-body-size".
func (self *ErrorCode) HTTPRequestBodySize() *cm.Option[uint64] {
	return cm.Case[cm.Option[uint64]](self, 17)
}

// ErrorCodeHTTPRequestMethodInvalid returns a [ErrorCode] of case "HTTP-request-method-invalid".
func ErrorCodeHTTPRequestMethodInvalid() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](18, data)
}

// HTTPRequestMethodInvalid returns true if [ErrorCode] represents the variant case "HTTP-request-method-invalid".
func (self *ErrorCode) HTTPRequestMethodInvalid() bool {
	return self.Tag() == 18
}

// ErrorCodeHTTPRequestURIInvalid returns a [ErrorCode] of case "HTTP-request-URI-invalid".
func ErrorCodeHTTPRequestURIInvalid() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](19, data)
}

// HTTPRequestURIInvalid returns true if [ErrorCode] represents the variant case "HTTP-request-URI-invalid".
func (self *ErrorCode) HTTPRequestURIInvalid() bool {
	return self.Tag() == 19
}

// ErrorCodeHTTPRequestURITooLong returns a [ErrorCode] of case "HTTP-request-URI-too-long".
func ErrorCodeHTTPRequestURITooLong() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](20, data)
}

// HTTPRequestURITooLong returns true if [ErrorCode] represents the variant case "HTTP-request-URI-too-long".
func (self *ErrorCode) HTTPRequestURITooLong() bool {
	return self.Tag() == 20
}

// ErrorCodeHTTPRequestHeaderSectionSize returns a [ErrorCode] of case "HTTP-request-header-section-size".
func ErrorCodeHTTPRequestHeaderSectionSize(data cm.Option[uint32]) ErrorCode {
	return cm.New[ErrorCode](21, data)
}

// HTTPRequestHeaderSectionSize returns a non-nil *[cm.Option[uint32]] if [ErrorCode] represents the variant case "HTTP-request-header-section-size".
func (self *ErrorCode) HTTPRequestHeaderSectionSize() *cm.Option[uint32] {
	return cm.Case[cm.Option[uint32]](self, 21)
}

// ErrorCodeHTTPRequestHeaderSize returns a [ErrorCode] of case "HTTP-request-header-size".
func ErrorCodeHTTPRequestHeaderSize(data cm.Option[FieldSizePayload]) ErrorCode {
	return cm.New[ErrorCode](22, data)
}

// HTTPRequestHeaderSize returns a non-nil *[cm.Option[FieldSizePayload]] if [ErrorCode] represents the variant case "HTTP-request-header-size".
func (self *ErrorCode) HTTPRequestHeaderSize() *cm.Option[FieldSizePayload] {
	return cm.Case[cm.Option[FieldSizePayload]](self, 22)
}

// ErrorCodeHTTPRequestTrailerSectionSize returns a [ErrorCode] of case "HTTP-request-trailer-section-size".
func ErrorCodeHTTPRequestTrailerSectionSize(data cm.Option[uint32]) ErrorCode {
	return cm.New[ErrorCode](23, data)
}

// HTTPRequestTrailerSectionSize returns a non-nil *[cm.Option[uint32]] if [ErrorCode] represents the variant case "HTTP-request-trailer-section-size".
func (self *ErrorCode) HTTPRequestTrailerSectionSize() *cm.Option[uint32] {
	return cm.Case[cm.Option[uint32]](self, 23)
}

// ErrorCodeHTTPRequestTrailerSize returns a [ErrorCode] of case "HTTP-request-trailer-size".
func ErrorCodeHTTPRequestTrailerSize(data FieldSizePayload) ErrorCode {
	return cm.New[ErrorCode](24, data)
}

// HTTPRequestTrailerSize returns a non-nil *[FieldSizePayload] if [ErrorCode] represents the variant case "HTTP-request-trailer-size".
func (self *ErrorCode) HTTPRequestTrailerSize() *FieldSizePayload {
	return cm.Case[FieldSizePayload](self, 24)
}

// ErrorCodeHTTPResponseIncomplete returns a [ErrorCode] of case "HTTP-response-incomplete".
func ErrorCodeHTTPResponseIncomplete() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](25, data)
}

// HTTPResponseIncomplete returns true if [ErrorCode] represents the variant case "HTTP-response-incomplete".
func (self *ErrorCode) HTTPResponseIncomplete() bool {
	return self.Tag() == 25
}

// ErrorCodeHTTPResponseHeaderSectionSize returns a [ErrorCode] of case "HTTP-response-header-section-size".
func ErrorCodeHTTPResponseHeaderSectionSize(data cm.Option[uint32]) ErrorCode {
	return cm.New[ErrorCode](26, data)
}

// HTTPResponseHeaderSectionSize returns a non-nil *[cm.Option[uint32]] if [ErrorCode] represents the variant case "HTTP-response-header-section-size".
func (self *ErrorCode) HTTPResponseHeaderSectionSize() *cm.Option[uint32] {
	return cm.Case[cm.Option[uint32]](self, 26)
}

// ErrorCodeHTTPResponseHeaderSize returns a [ErrorCode] of case "HTTP-response-header-size".
func ErrorCodeHTTPResponseHeaderSize(data FieldSizePayload) ErrorCode {
	return cm.New[ErrorCode](27, data)
}

// HTTPResponseHeaderSize returns a non-nil *[FieldSizePayload] if [ErrorCode] represents the variant case "HTTP-response-header-size".
func (self *ErrorCode) HTTPResponseHeaderSize() *FieldSizePayload {
	return cm.Case[FieldSizePayload](self, 27)
}

// ErrorCodeHTTPResponseBodySize returns a [ErrorCode] of case "HTTP-response-body-size".
func ErrorCodeHTTPResponseBodySize(data cm.Option[uint64]) ErrorCode {
	return cm.New[ErrorCode](28, data)
}

// HTTPResponseBodySize returns a non-nil *[cm.Option[uint64]] if [ErrorCode] represents the variant case "HTTP-response-body-size".
func (self *ErrorCode) HTTPResponseBodySize() *cm.Option[uint64] {
	return cm.Case[cm.Option[uint64]](self, 28)
}

// ErrorCodeHTTPResponseTrailerSectionSize returns a [ErrorCode] of case "HTTP-response-trailer-section-size".
func ErrorCodeHTTPResponseTrailerSectionSize(data cm.Option[uint32]) ErrorCode {
	return cm.New[ErrorCode](29, data)
}

// HTTPResponseTrailerSectionSize returns a non-nil *[cm.Option[uint32]] if [ErrorCode] represents the variant case "HTTP-response-trailer-section-size".
func (self *ErrorCode) HTTPResponseTrailerSectionSize() *cm.Option[uint32] {
	return cm.Case[cm.Option[uint32]](self, 29)
}

// ErrorCodeHTTPResponseTrailerSize returns a [ErrorCode] of case "HTTP-response-trailer-size".
func ErrorCodeHTTPResponseTrailerSize(data FieldSizePayload) ErrorCode {
	return cm.New[ErrorCode](30, data)
}

// HTTPResponseTrailerSize returns a non-nil *[FieldSizePayload] if [ErrorCode] represents the variant case "HTTP-response-trailer-size".
func (self *ErrorCode) HTTPResponseTrailerSize() *FieldSizePayload {
	return cm.Case[FieldSizePayload](self, 30)
}

// ErrorCodeHTTPResponseTransferCoding returns a [ErrorCode] of case "HTTP-response-transfer-coding".
func ErrorCodeHTTPResponseTransferCoding(data cm.Option[string]) ErrorCode {
	return cm.New[ErrorCode](31, data)
}

// HTTPResponseTransferCoding returns a non-nil *[cm.Option[string]] if [ErrorCode] represents the variant case "HTTP-response-transfer-coding".
func (self *ErrorCode) HTTPResponseTransferCoding() *cm.Option[string] {
	return cm.Case[cm.Option[string]](self, 31)
}

// ErrorCodeHTTPResponseContentCoding returns a [ErrorCode] of case "HTTP-response-content-coding".
func ErrorCodeHTTPResponseContentCoding(data cm.Option[string]) ErrorCode {
	return cm.New[ErrorCode](32, data)
}

// HTTPResponseContentCoding returns a non-nil *[cm.Option[string]] if [ErrorCode] represents the variant case "HTTP-response-content-coding".
func (self *ErrorCode) HTTPResponseContentCoding() *cm.Option[string] {
	return cm.Case[cm.Option[string]](self, 32)
}

// ErrorCodeHTTPResponseTimeout returns a [ErrorCode] of case "HTTP-response-timeout".
func ErrorCodeHTTPResponseTimeout() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](33, data)
}

// HTTPResponseTimeout returns true if [ErrorCode] represents the variant case "HTTP-response-timeout".
func (self *ErrorCode) HTTPResponseTimeout() bool {
	return self.Tag() == 33
}

// ErrorCodeHTTPUpgradeFailed returns a [ErrorCode] of case "HTTP-upgrade-failed".
func ErrorCodeHTTPUpgradeFailed() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](34, data)
}

// HTTPUpgradeFailed returns true if [ErrorCode] represents the variant case "HTTP-upgrade-failed".
func (self *ErrorCode) HTTPUpgradeFailed() bool {
	return self.Tag() == 34
}

// ErrorCodeHTTPProtocolError returns a [ErrorCode] of case "HTTP-protocol-error".
func ErrorCodeHTTPProtocolError() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](35, data)
}

// HTTPProtocolError returns true if [ErrorCode] represents the variant case "HTTP-protocol-error".
func (self *ErrorCode) HTTPProtocolError() bool {
	return self.Tag() == 35
}

// ErrorCodeLoopDetected returns a [ErrorCode] of case "loop-detected".
func ErrorCodeLoopDetected() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](36, data)
}

// LoopDetected returns true if [ErrorCode] represents the variant case "loop-detected".
func (self *ErrorCode) LoopDetected() bool {
	return self.Tag() == 36
}

// ErrorCodeConfigurationError returns a [ErrorCode] of case "configuration-error".
func ErrorCodeConfigurationError() ErrorCode {
	var data struct{}
	return cm.New[ErrorCode](37, data)
}

// ConfigurationError returns true if [ErrorCode] represents the variant case "configuration-error".
func (self *ErrorCode) ConfigurationError() bool {
	return self.Tag() == 37
}

// ErrorCodeInternalError returns a [ErrorCode] of case "internal-error".
//
// This is a catch-all error for anything that doesn't fit cleanly into a
// more specific case. It also includes an optional string for an
// unstructured description of the error. Users should not depend on the
// string for diagnosing errors, as it's not required to be consistent
// between implementations.
func ErrorCodeInternalError(data cm.Option[string]) ErrorCode {
	return cm.New[ErrorCode](38, data)
}

// InternalError returns a non-nil *[cm.Option[string]] if [ErrorCode] represents the variant case "internal-error".
func (self *ErrorCode) InternalError() *cm.Option[string] {
	return cm.Case[cm.Option[string]](self, 38)
}

var stringsErrorCode = [39]string{
	"DNS-timeout",
	"DNS-error",
	"destination-not-found",
	"destination-unavailable",
	"destination-IP-prohibited",
	"destination-IP-unroutable",
	"connection-refused",
	"connection-terminated",
	"connection-timeout",
	"connection-read-timeout",
	"connection-write-timeout",
	"connection-limit-reached",
	"TLS-protocol-error",
	"TLS-certificate-error",
	"TLS-alert-received",
	"HTTP-request-denied",
	"HTTP-request-length-required",
	"HTTP-request-body-size",
	"HTTP-request-method-invalid",
	"HTTP-request-URI-invalid",
	"HTTP-request-URI-too-long",
	"HTTP-request-header-section-size",
	"HTTP-request-header-size",
	"HTTP-request-trailer-section-size",
	"HTTP-request-trailer-size",
	"HTTP-response-incomplete",
	"HTTP-response-header-section-size",
	"HTTP-response-header-size",
	"HTTP-response-body-size",
	"HTTP-response-trailer-section-size",
	"HTTP-response-trailer-size",
	"HTTP-response-transfer-coding",
	"HTTP-response-content-coding",
	"HTTP-response-timeout",
	"HTTP-upgrade-failed",
	"HTTP-protocol-error",
	"loop-detected",
	"configuration-error",
	"internal-error",
}

// String implements [fmt.Stringer], returning the variant case name of v.
func (v ErrorCode) String() string {
	return stringsErrorCode[v.Tag()]
}

// HeaderError represents the variant "wasi:http/types@0.2.0#header-error".
//
// This type enumerates the different kinds of errors that may occur when
// setting or appending to a `fields` resource.
//
//	variant header-error {
//		invalid-syntax,
//		forbidden,
//		immutable,
//	}
type HeaderError uint8

const (
	// This error indicates that a `field-key` or `field-value` was
	// syntactically invalid when used with an operation that sets headers in a
	// `fields`.
	HeaderErrorInvalidSyntax HeaderError = iota

	// This error indicates that a forbidden `field-key` was used when trying
	// to set a header in a `fields`.
	HeaderErrorForbidden

	// This error indicates that the operation on the `fields` was not
	// permitted because the fields are immutable.
	HeaderErrorImmutable
)

var stringsHeaderError = [3]string{
	"invalid-syntax",
	"forbidden",
	"immutable",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e HeaderError) String() string {
	return stringsHeaderError[e]
}

// FieldKey represents the string "wasi:http/types@0.2.0#field-key".
//
// Field keys are always strings.
//
//	type field-key = string
type FieldKey string

// FieldValue represents the list "wasi:http/types@0.2.0#field-value".
//
// Field values should always be ASCII strings. However, in
// reality, HTTP implementations often have to interpret malformed values,
// so they are provided as a list of bytes.
//
//	type field-value = list<u8>
type FieldValue cm.List[uint8]

// Fields represents the imported resource "wasi:http/types@0.2.0#fields".
//
// This following block defines the `fields` resource which corresponds to
// HTTP standard Fields. Fields are a common representation used for both
// Headers and Trailers.
//
// A `fields` may be mutable or immutable. A `fields` created using the
// constructor, `from-list`, or `clone` will be mutable, but a `fields`
// resource given by other means (including, but not limited to,
// `incoming-request.headers`, `outgoing-request.headers`) might be be
// immutable. In an immutable fields, the `set`, `append`, and `delete`
// operations will fail with `header-error.immutable`.
//
//	resource fields
type Fields cm.Resource

// ResourceDrop represents the imported resource-drop for resource "fields".
//
// Drops a resource handle.
//
//go:nosplit
func (self Fields) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_FieldsResourceDrop((uint32)(self0))
	return
}

// NewFields represents the imported constructor for resource "fields".
//
// Construct an empty HTTP Fields.
//
// The resulting `fields` is mutable.
//
//	constructor()
//
//go:nosplit
func NewFields() (result Fields) {
	result0 := wasmimport_NewFields()
	result = cm.Reinterpret[Fields]((uint32)(result0))
	return
}

// FieldsFromList represents the imported static function "from-list".
//
// Construct an HTTP Fields.
//
// The resulting `fields` is mutable.
//
// The list represents each key-value pair in the Fields. Keys
// which have multiple values are represented by multiple entries in this
// list with the same key.
//
// The tuple is a pair of the field key, represented as a string, and
// Value, represented as a list of bytes. In a valid Fields, all keys
// and values are valid UTF-8 strings. However, values are not always
// well-formed, so they are represented as a raw list of bytes.
//
// An error result will be returned if any header or value was
// syntactically invalid, or if a header was forbidden.
//
//	from-list: static func(entries: list<tuple<field-key, field-value>>) -> result<fields,
//	header-error>
//
//go:nosplit
func FieldsFromList(entries cm.List[cm.Tuple[FieldKey, FieldValue]]) (result cm.Result[Fields, Fields, HeaderError]) {
	entries0, entries1 := cm.LowerList(entries)
	wasmimport_FieldsFromList((*cm.Tuple[FieldKey, FieldValue])(entries0), (uint32)(entries1), &result)
	return
}

// Append represents the imported method "append".
//
// Append a value for a key. Does not change or delete any existing
// values for that key.
//
// Fails with `header-error.immutable` if the `fields` are immutable.
//
//	append: func(name: field-key, value: field-value) -> result<_, header-error>
//
//go:nosplit
func (self Fields) Append(name FieldKey, value FieldValue) (result cm.Result[HeaderError, struct{}, HeaderError]) {
	self0 := cm.Reinterpret[uint32](self)
	name0, name1 := cm.LowerString(name)
	value0, value1 := cm.LowerList(value)
	wasmimport_FieldsAppend((uint32)(self0), (*uint8)(name0), (uint32)(name1), (*uint8)(value0), (uint32)(value1), &result)
	return
}

// Clone represents the imported method "clone".
//
// Make a deep copy of the Fields. Equivelant in behavior to calling the
// `fields` constructor on the return value of `entries`. The resulting
// `fields` is mutable.
//
//	clone: func() -> fields
//
//go:nosplit
func (self Fields) Clone() (result Fields) {
	self0 := cm.Reinterpret[uint32](self)
	result0 := wasmimport_FieldsClone((uint32)(self0))
	result = cm.Reinterpret[Fields]((uint32)(result0))
	return
}

// Delete represents the imported method "delete".
//
// Delete all values for a key. Does nothing if no values for the key
// exist.
//
// Fails with `header-error.immutable` if the `fields` are immutable.
//
//	delete: func(name: field-key) -> result<_, header-error>
//
//go:nosplit
func (self Fields) Delete(name FieldKey) (result cm.Result[HeaderError, struct{}, HeaderError]) {
	self0 := cm.Reinterpret[uint32](self)
	name0, name1 := cm.LowerString(name)
	wasmimport_FieldsDelete((uint32)(self0), (*uint8)(name0), (uint32)(name1), &result)
	return
}

// Entries represents the imported method "entries".
//
// Retrieve the full set of keys and values in the Fields. Like the
// constructor, the list represents each key-value pair.
//
// The outer list represents each key-value pair in the Fields. Keys
// which have multiple values are represented by multiple entries in this
// list with the same key.
//
//	entries: func() -> list<tuple<field-key, field-value>>
//
//go:nosplit
func (self Fields) Entries() (result cm.List[cm.Tuple[FieldKey, FieldValue]]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_FieldsEntries((uint32)(self0), &result)
	return
}

// Get represents the imported method "get".
//
// Get all of the values corresponding to a key. If the key is not present
// in this `fields`, an empty list is returned. However, if the key is
// present but empty, this is represented by a list with one or more
// empty field-values present.
//
//	get: func(name: field-key) -> list<field-value>
//
//go:nosplit
func (self Fields) Get(name FieldKey) (result cm.List[FieldValue]) {
	self0 := cm.Reinterpret[uint32](self)
	name0, name1 := cm.LowerString(name)
	wasmimport_FieldsGet((uint32)(self0), (*uint8)(name0), (uint32)(name1), &result)
	return
}

// Has represents the imported method "has".
//
// Returns `true` when the key is present in this `fields`. If the key is
// syntactically invalid, `false` is returned.
//
//	has: func(name: field-key) -> bool
//
//go:nosplit
func (self Fields) Has(name FieldKey) (result bool) {
	self0 := cm.Reinterpret[uint32](self)
	name0, name1 := cm.LowerString(name)
	result0 := wasmimport_FieldsHas((uint32)(self0), (*uint8)(name0), (uint32)(name1))
	result = cm.U32ToBool((uint32)(result0))
	return
}

// Set represents the imported method "set".
//
// Set all of the values for a key. Clears any existing values for that
// key, if they have been set.
//
// Fails with `header-error.immutable` if the `fields` are immutable.
//
//	set: func(name: field-key, value: list<field-value>) -> result<_, header-error>
//
//go:nosplit
func (self Fields) Set(name FieldKey, value cm.List[FieldValue]) (result cm.Result[HeaderError, struct{}, HeaderError]) {
	self0 := cm.Reinterpret[uint32](self)
	name0, name1 := cm.LowerString(name)
	value0, value1 := cm.LowerList(value)
	wasmimport_FieldsSet((uint32)(self0), (*uint8)(name0), (uint32)(name1), (*FieldValue)(value0), (uint32)(value1), &result)
	return
}

// Headers represents the imported type alias "wasi:http/types@0.2.0#headers".
//
// See [Fields] for more information.
type Headers = Fields

// Trailers represents the imported type alias "wasi:http/types@0.2.0#trailers".
//
// See [Fields] for more information.
type Trailers = Fields

// IncomingRequest represents the imported resource "wasi:http/types@0.2.0#incoming-request".
//
// Represents an incoming HTTP Request.
//
//	resource incoming-request
type IncomingRequest cm.Resource

// ResourceDrop represents the imported resource-drop for resource "incoming-request".
//
// Drops a resource handle.
//
//go:nosplit
func (self IncomingRequest) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_IncomingRequestResourceDrop((uint32)(self0))
	return
}

// Authority represents the imported method "authority".
//
// Returns the authority from the request, if it was present.
//
//	authority: func() -> option<string>
//
//go:nosplit
func (self IncomingRequest) Authority() (result cm.Option[string]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_IncomingRequestAuthority((uint32)(self0), &result)
	return
}

// Consume represents the imported method "consume".
//
// Gives the `incoming-body` associated with this request. Will only
// return success at most once, and subsequent calls will return error.
//
//	consume: func() -> result<incoming-body>
//
//go:nosplit
func (self IncomingRequest) Consume() (result cm.Result[IncomingBody, IncomingBody, struct{}]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_IncomingRequestConsume((uint32)(self0), &result)
	return
}

// Headers represents the imported method "headers".
//
// Get the `headers` associated with the request.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// The `headers` returned are a child resource: it must be dropped before
// the parent `incoming-request` is dropped. Dropping this
// `incoming-request` before all children are dropped will trap.
//
//	headers: func() -> headers
//
//go:nosplit
func (self IncomingRequest) Headers() (result Headers) {
	self0 := cm.Reinterpret[uint32](self)
	result0 := wasmimport_IncomingRequestHeaders((uint32)(self0))
	result = cm.Reinterpret[Headers]((uint32)(result0))
	return
}

// Method represents the imported method "method".
//
// Returns the method of the incoming request.
//
//	method: func() -> method
//
//go:nosplit
func (self IncomingRequest) Method() (result Method) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_IncomingRequestMethod((uint32)(self0), &result)
	return
}

// PathWithQuery represents the imported method "path-with-query".
//
// Returns the path with query parameters from the request, as a string.
//
//	path-with-query: func() -> option<string>
//
//go:nosplit
func (self IncomingRequest) PathWithQuery() (result cm.Option[string]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_IncomingRequestPathWithQuery((uint32)(self0), &result)
	return
}

// Scheme represents the imported method "scheme".
//
// Returns the protocol scheme from the request.
//
//	scheme: func() -> option<scheme>
//
//go:nosplit
func (self IncomingRequest) Scheme() (result cm.Option[Scheme]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_IncomingRequestScheme((uint32)(self0), &result)
	return
}

// OutgoingRequest represents the imported resource "wasi:http/types@0.2.0#outgoing-request".
//
// Represents an outgoing HTTP Request.
//
//	resource outgoing-request
type OutgoingRequest cm.Resource

// ResourceDrop represents the imported resource-drop for resource "outgoing-request".
//
// Drops a resource handle.
//
//go:nosplit
func (self OutgoingRequest) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_OutgoingRequestResourceDrop((uint32)(self0))
	return
}

// NewOutgoingRequest represents the imported constructor for resource "outgoing-request".
//
// Construct a new `outgoing-request` with a default `method` of `GET`, and
// `none` values for `path-with-query`, `scheme`, and `authority`.
//
// * `headers` is the HTTP Headers for the Request.
//
// It is possible to construct, or manipulate with the accessor functions
// below, an `outgoing-request` with an invalid combination of `scheme`
// and `authority`, or `headers` which are not permitted to be sent.
// It is the obligation of the `outgoing-handler.handle` implementation
// to reject invalid constructions of `outgoing-request`.
//
//	constructor(headers: headers)
//
//go:nosplit
func NewOutgoingRequest(headers Headers) (result OutgoingRequest) {
	headers0 := cm.Reinterpret[uint32](headers)
	result0 := wasmimport_NewOutgoingRequest((uint32)(headers0))
	result = cm.Reinterpret[OutgoingRequest]((uint32)(result0))
	return
}

// Authority represents the imported method "authority".
//
// Get the HTTP Authority for the Request. A value of `none` may be used
// with Related Schemes which do not require an Authority. The HTTP and
// HTTPS schemes always require an authority.
//
//	authority: func() -> option<string>
//
//go:nosplit
func (self OutgoingRequest) Authority() (result cm.Option[string]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_OutgoingRequestAuthority((uint32)(self0), &result)
	return
}

// Body represents the imported method "body".
//
// Returns the resource corresponding to the outgoing Body for this
// Request.
//
// Returns success on the first call: the `outgoing-body` resource for
// this `outgoing-request` can be retrieved at most once. Subsequent
// calls will return error.
//
//	body: func() -> result<outgoing-body>
//
//go:nosplit
func (self OutgoingRequest) Body() (result cm.Result[OutgoingBody, OutgoingBody, struct{}]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_OutgoingRequestBody((uint32)(self0), &result)
	return
}

// Headers represents the imported method "headers".
//
// Get the headers associated with the Request.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// This headers resource is a child: it must be dropped before the parent
// `outgoing-request` is dropped, or its ownership is transfered to
// another component by e.g. `outgoing-handler.handle`.
//
//	headers: func() -> headers
//
//go:nosplit
func (self OutgoingRequest) Headers() (result Headers) {
	self0 := cm.Reinterpret[uint32](self)
	result0 := wasmimport_OutgoingRequestHeaders((uint32)(self0))
	result = cm.Reinterpret[Headers]((uint32)(result0))
	return
}

// Method represents the imported method "method".
//
// Get the Method for the Request.
//
//	method: func() -> method
//
//go:nosplit
func (self OutgoingRequest) Method() (result Method) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_OutgoingRequestMethod((uint32)(self0), &result)
	return
}

// PathWithQuery represents the imported method "path-with-query".
//
// Get the combination of the HTTP Path and Query for the Request.
// When `none`, this represents an empty Path and empty Query.
//
//	path-with-query: func() -> option<string>
//
//go:nosplit
func (self OutgoingRequest) PathWithQuery() (result cm.Option[string]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_OutgoingRequestPathWithQuery((uint32)(self0), &result)
	return
}

// Scheme represents the imported method "scheme".
//
// Get the HTTP Related Scheme for the Request. When `none`, the
// implementation may choose an appropriate default scheme.
//
//	scheme: func() -> option<scheme>
//
//go:nosplit
func (self OutgoingRequest) Scheme() (result cm.Option[Scheme]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_OutgoingRequestScheme((uint32)(self0), &result)
	return
}

// SetAuthority represents the imported method "set-authority".
//
// Set the HTTP Authority for the Request. A value of `none` may be used
// with Related Schemes which do not require an Authority. The HTTP and
// HTTPS schemes always require an authority. Fails if the string given is
// not a syntactically valid uri authority.
//
//	set-authority: func(authority: option<string>) -> result
//
//go:nosplit
func (self OutgoingRequest) SetAuthority(authority cm.Option[string]) (result cm.BoolResult) {
	self0 := cm.Reinterpret[uint32](self)
	authority0, authority1, authority2 := lower_OptionString(authority)
	result0 := wasmimport_OutgoingRequestSetAuthority((uint32)(self0), (uint32)(authority0), (*uint8)(authority1), (uint32)(authority2))
	result = (cm.BoolResult)(cm.U32ToBool((uint32)(result0)))
	return
}

// SetMethod represents the imported method "set-method".
//
// Set the Method for the Request. Fails if the string present in a
// `method.other` argument is not a syntactically valid method.
//
//	set-method: func(method: method) -> result
//
//go:nosplit
func (self OutgoingRequest) SetMethod(method Method) (result cm.BoolResult) {
	self0 := cm.Reinterpret[uint32](self)
	method0, method1, method2 := lower_Method(method)
	result0 := wasmimport_OutgoingRequestSetMethod((uint32)(self0), (uint32)(method0), (*uint8)(method1), (uint32)(method2))
	result = (cm.BoolResult)(cm.U32ToBool((uint32)(result0)))
	return
}

// SetPathWithQuery represents the imported method "set-path-with-query".
//
// Set the combination of the HTTP Path and Query for the Request.
// When `none`, this represents an empty Path and empty Query. Fails is the
// string given is not a syntactically valid path and query uri component.
//
//	set-path-with-query: func(path-with-query: option<string>) -> result
//
//go:nosplit
func (self OutgoingRequest) SetPathWithQuery(pathWithQuery cm.Option[string]) (result cm.BoolResult) {
	self0 := cm.Reinterpret[uint32](self)
	pathWithQuery0, pathWithQuery1, pathWithQuery2 := lower_OptionString(pathWithQuery)
	result0 := wasmimport_OutgoingRequestSetPathWithQuery((uint32)(self0), (uint32)(pathWithQuery0), (*uint8)(pathWithQuery1), (uint32)(pathWithQuery2))
	result = (cm.BoolResult)(cm.U32ToBool((uint32)(result0)))
	return
}

// SetScheme represents the imported method "set-scheme".
//
// Set the HTTP Related Scheme for the Request. When `none`, the
// implementation may choose an appropriate default scheme. Fails if the
// string given is not a syntactically valid uri scheme.
//
//	set-scheme: func(scheme: option<scheme>) -> result
//
//go:nosplit
func (self OutgoingRequest) SetScheme(scheme cm.Option[Scheme]) (result cm.BoolResult) {
	self0 := cm.Reinterpret[uint32](self)
	scheme0, scheme1, scheme2, scheme3 := lower_OptionScheme(scheme)
	result0 := wasmimport_OutgoingRequestSetScheme((uint32)(self0), (uint32)(scheme0), (uint32)(scheme1), (*uint8)(scheme2), (uint32)(scheme3))
	result = (cm.BoolResult)(cm.U32ToBool((uint32)(result0)))
	return
}

// RequestOptions represents the imported resource "wasi:http/types@0.2.0#request-options".
//
// Parameters for making an HTTP Request. Each of these parameters is
// currently an optional timeout applicable to the transport layer of the
// HTTP protocol.
//
// These timeouts are separate from any the user may use to bound a
// blocking call to `wasi:io/poll.poll`.
//
//	resource request-options
type RequestOptions cm.Resource

// ResourceDrop represents the imported resource-drop for resource "request-options".
//
// Drops a resource handle.
//
//go:nosplit
func (self RequestOptions) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_RequestOptionsResourceDrop((uint32)(self0))
	return
}

// NewRequestOptions represents the imported constructor for resource "request-options".
//
// Construct a default `request-options` value.
//
//	constructor()
//
//go:nosplit
func NewRequestOptions() (result RequestOptions) {
	result0 := wasmimport_NewRequestOptions()
	result = cm.Reinterpret[RequestOptions]((uint32)(result0))
	return
}

// BetweenBytesTimeout represents the imported method "between-bytes-timeout".
//
// The timeout for receiving subsequent chunks of bytes in the Response
// body stream.
//
//	between-bytes-timeout: func() -> option<duration>
//
//go:nosplit
func (self RequestOptions) BetweenBytesTimeout() (result cm.Option[Duration]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_RequestOptionsBetweenBytesTimeout((uint32)(self0), &result)
	return
}

// ConnectTimeout represents the imported method "connect-timeout".
//
// The timeout for the initial connect to the HTTP Server.
//
//	connect-timeout: func() -> option<duration>
//
//go:nosplit
func (self RequestOptions) ConnectTimeout() (result cm.Option[Duration]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_RequestOptionsConnectTimeout((uint32)(self0), &result)
	return
}

// FirstByteTimeout represents the imported method "first-byte-timeout".
//
// The timeout for receiving the first byte of the Response body.
//
//	first-byte-timeout: func() -> option<duration>
//
//go:nosplit
func (self RequestOptions) FirstByteTimeout() (result cm.Option[Duration]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_RequestOptionsFirstByteTimeout((uint32)(self0), &result)
	return
}

// SetBetweenBytesTimeout represents the imported method "set-between-bytes-timeout".
//
// Set the timeout for receiving subsequent chunks of bytes in the Response
// body stream. An error return value indicates that this timeout is not
// supported.
//
//	set-between-bytes-timeout: func(duration: option<duration>) -> result
//
//go:nosplit
func (self RequestOptions) SetBetweenBytesTimeout(duration cm.Option[Duration]) (result cm.BoolResult) {
	self0 := cm.Reinterpret[uint32](self)
	duration0, duration1 := lower_OptionDuration(duration)
	result0 := wasmimport_RequestOptionsSetBetweenBytesTimeout((uint32)(self0), (uint32)(duration0), (uint64)(duration1))
	result = (cm.BoolResult)(cm.U32ToBool((uint32)(result0)))
	return
}

// SetConnectTimeout represents the imported method "set-connect-timeout".
//
// Set the timeout for the initial connect to the HTTP Server. An error
// return value indicates that this timeout is not supported.
//
//	set-connect-timeout: func(duration: option<duration>) -> result
//
//go:nosplit
func (self RequestOptions) SetConnectTimeout(duration cm.Option[Duration]) (result cm.BoolResult) {
	self0 := cm.Reinterpret[uint32](self)
	duration0, duration1 := lower_OptionDuration(duration)
	result0 := wasmimport_RequestOptionsSetConnectTimeout((uint32)(self0), (uint32)(duration0), (uint64)(duration1))
	result = (cm.BoolResult)(cm.U32ToBool((uint32)(result0)))
	return
}

// SetFirstByteTimeout represents the imported method "set-first-byte-timeout".
//
// Set the timeout for receiving the first byte of the Response body. An
// error return value indicates that this timeout is not supported.
//
//	set-first-byte-timeout: func(duration: option<duration>) -> result
//
//go:nosplit
func (self RequestOptions) SetFirstByteTimeout(duration cm.Option[Duration]) (result cm.BoolResult) {
	self0 := cm.Reinterpret[uint32](self)
	duration0, duration1 := lower_OptionDuration(duration)
	result0 := wasmimport_RequestOptionsSetFirstByteTimeout((uint32)(self0), (uint32)(duration0), (uint64)(duration1))
	result = (cm.BoolResult)(cm.U32ToBool((uint32)(result0)))
	return
}

// ResponseOutparam represents the imported resource "wasi:http/types@0.2.0#response-outparam".
//
// Represents the ability to send an HTTP Response.
//
// This resource is used by the `wasi:http/incoming-handler` interface to
// allow a Response to be sent corresponding to the Request provided as the
// other argument to `incoming-handler.handle`.
//
//	resource response-outparam
type ResponseOutparam cm.Resource

// ResourceDrop represents the imported resource-drop for resource "response-outparam".
//
// Drops a resource handle.
//
//go:nosplit
func (self ResponseOutparam) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_ResponseOutparamResourceDrop((uint32)(self0))
	return
}

// ResponseOutparamSet represents the imported static function "set".
//
// Set the value of the `response-outparam` to either send a response,
// or indicate an error.
//
// This method consumes the `response-outparam` to ensure that it is
// called at most once. If it is never called, the implementation
// will respond with an error.
//
// The user may provide an `error` to `response` to allow the
// implementation determine how to respond with an HTTP error response.
//
//	set: static func(param: response-outparam, response: result<outgoing-response,
//	error-code>)
//
//go:nosplit
func ResponseOutparamSet(param ResponseOutparam, response cm.Result[ErrorCodeShape, OutgoingResponse, ErrorCode]) {
	param0 := cm.Reinterpret[uint32](param)
	response0, response1, response2, response3, response4, response5, response6, response7 := lower_ResultOutgoingResponseErrorCode(response)
	wasmimport_ResponseOutparamSet((uint32)(param0), (uint32)(response0), (uint32)(response1), (uint32)(response2), (uint64)(response3), (uint32)(response4), (uint32)(response5), (uint32)(response6), (uint32)(response7))
	return
}

// StatusCode represents the u16 "wasi:http/types@0.2.0#status-code".
//
// This type corresponds to the HTTP standard Status Code.
//
//	type status-code = u16
type StatusCode uint16

// IncomingResponse represents the imported resource "wasi:http/types@0.2.0#incoming-response".
//
// Represents an incoming HTTP Response.
//
//	resource incoming-response
type IncomingResponse cm.Resource

// ResourceDrop represents the imported resource-drop for resource "incoming-response".
//
// Drops a resource handle.
//
//go:nosplit
func (self IncomingResponse) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_IncomingResponseResourceDrop((uint32)(self0))
	return
}

// Consume represents the imported method "consume".
//
// Returns the incoming body. May be called at most once. Returns error
// if called additional times.
//
//	consume: func() -> result<incoming-body>
//
//go:nosplit
func (self IncomingResponse) Consume() (result cm.Result[IncomingBody, IncomingBody, struct{}]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_IncomingResponseConsume((uint32)(self0), &result)
	return
}

// Headers represents the imported method "headers".
//
// Returns the headers from the incoming response.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// This headers resource is a child: it must be dropped before the parent
// `incoming-response` is dropped.
//
//	headers: func() -> headers
//
//go:nosplit
func (self IncomingResponse) Headers() (result Headers) {
	self0 := cm.Reinterpret[uint32](self)
	result0 := wasmimport_IncomingResponseHeaders((uint32)(self0))
	result = cm.Reinterpret[Headers]((uint32)(result0))
	return
}

// Status represents the imported method "status".
//
// Returns the status code from the incoming response.
//
//	status: func() -> status-code
//
//go:nosplit
func (self IncomingResponse) Status() (result StatusCode) {
	self0 := cm.Reinterpret[uint32](self)
	result0 := wasmimport_IncomingResponseStatus((uint32)(self0))
	result = (StatusCode)((uint32)(result0))
	return
}

// IncomingBody represents the imported resource "wasi:http/types@0.2.0#incoming-body".
//
// Represents an incoming HTTP Request or Response's Body.
//
// A body has both its contents - a stream of bytes - and a (possibly
// empty) set of trailers, indicating that the full contents of the
// body have been received. This resource represents the contents as
// an `input-stream` and the delivery of trailers as a `future-trailers`,
// and ensures that the user of this interface may only be consuming either
// the body contents or waiting on trailers at any given time.
//
//	resource incoming-body
type IncomingBody cm.Resource

// ResourceDrop represents the imported resource-drop for resource "incoming-body".
//
// Drops a resource handle.
//
//go:nosplit
func (self IncomingBody) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_IncomingBodyResourceDrop((uint32)(self0))
	return
}

// IncomingBodyFinish represents the imported static function "finish".
//
// Takes ownership of `incoming-body`, and returns a `future-trailers`.
// This function will trap if the `input-stream` child is still alive.
//
//	finish: static func(this: incoming-body) -> future-trailers
//
//go:nosplit
func IncomingBodyFinish(this IncomingBody) (result FutureTrailers) {
	this0 := cm.Reinterpret[uint32](this)
	result0 := wasmimport_IncomingBodyFinish((uint32)(this0))
	result = cm.Reinterpret[FutureTrailers]((uint32)(result0))
	return
}

// Stream represents the imported method "stream".
//
// Returns the contents of the body, as a stream of bytes.
//
// Returns success on first call: the stream representing the contents
// can be retrieved at most once. Subsequent calls will return error.
//
// The returned `input-stream` resource is a child: it must be dropped
// before the parent `incoming-body` is dropped, or consumed by
// `incoming-body.finish`.
//
// This invariant ensures that the implementation can determine whether
// the user is consuming the contents of the body, waiting on the
// `future-trailers` to be ready, or neither. This allows for network
// backpressure is to be applied when the user is consuming the body,
// and for that backpressure to not inhibit delivery of the trailers if
// the user does not read the entire body.
//
//	%stream: func() -> result<input-stream>
//
//go:nosplit
func (self IncomingBody) Stream() (result cm.Result[InputStream, InputStream, struct{}]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_IncomingBodyStream((uint32)(self0), &result)
	return
}

// FutureTrailers represents the imported resource "wasi:http/types@0.2.0#future-trailers".
//
// Represents a future which may eventaully return trailers, or an error.
//
// In the case that the incoming HTTP Request or Response did not have any
// trailers, this future will resolve to the empty set of trailers once the
// complete Request or Response body has been received.
//
//	resource future-trailers
type FutureTrailers cm.Resource

// ResourceDrop represents the imported resource-drop for resource "future-trailers".
//
// Drops a resource handle.
//
//go:nosplit
func (self FutureTrailers) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_FutureTrailersResourceDrop((uint32)(self0))
	return
}

// Get represents the imported method "get".
//
// Returns the contents of the trailers, or an error which occured,
// once the future is ready.
//
// The outer `option` represents future readiness. Users can wait on this
// `option` to become `some` using the `subscribe` method.
//
// The outer `result` is used to retrieve the trailers or error at most
// once. It will be success on the first call in which the outer option
// is `some`, and error on subsequent calls.
//
// The inner `result` represents that either the HTTP Request or Response
// body, as well as any trailers, were received successfully, or that an
// error occured receiving them. The optional `trailers` indicates whether
// or not trailers were present in the body.
//
// When some `trailers` are returned by this method, the `trailers`
// resource is immutable, and a child. Use of the `set`, `append`, or
// `delete` methods will return an error, and the resource must be
// dropped before the parent `future-trailers` is dropped.
//
//	get: func() -> option<result<result<option<trailers>, error-code>>>
//
//go:nosplit
func (self FutureTrailers) Get() (result cm.Option[cm.Result[cm.Result[ErrorCodeShape, cm.Option[Trailers], ErrorCode], cm.Result[ErrorCodeShape, cm.Option[Trailers], ErrorCode], struct{}]]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_FutureTrailersGet((uint32)(self0), &result)
	return
}

// Subscribe represents the imported method "subscribe".
//
// Returns a pollable which becomes ready when either the trailers have
// been received, or an error has occured. When this pollable is ready,
// the `get` method will return `some`.
//
//	subscribe: func() -> pollable
//
//go:nosplit
func (self FutureTrailers) Subscribe() (result Pollable) {
	self0 := cm.Reinterpret[uint32](self)
	result0 := wasmimport_FutureTrailersSubscribe((uint32)(self0))
	result = cm.Reinterpret[Pollable]((uint32)(result0))
	return
}

// OutgoingResponse represents the imported resource "wasi:http/types@0.2.0#outgoing-response".
//
// Represents an outgoing HTTP Response.
//
//	resource outgoing-response
type OutgoingResponse cm.Resource

// ResourceDrop represents the imported resource-drop for resource "outgoing-response".
//
// Drops a resource handle.
//
//go:nosplit
func (self OutgoingResponse) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_OutgoingResponseResourceDrop((uint32)(self0))
	return
}

// NewOutgoingResponse represents the imported constructor for resource "outgoing-response".
//
// Construct an `outgoing-response`, with a default `status-code` of `200`.
// If a different `status-code` is needed, it must be set via the
// `set-status-code` method.
//
// * `headers` is the HTTP Headers for the Response.
//
//	constructor(headers: headers)
//
//go:nosplit
func NewOutgoingResponse(headers Headers) (result OutgoingResponse) {
	headers0 := cm.Reinterpret[uint32](headers)
	result0 := wasmimport_NewOutgoingResponse((uint32)(headers0))
	result = cm.Reinterpret[OutgoingResponse]((uint32)(result0))
	return
}

// Body represents the imported method "body".
//
// Returns the resource corresponding to the outgoing Body for this Response.
//
// Returns success on the first call: the `outgoing-body` resource for
// this `outgoing-response` can be retrieved at most once. Subsequent
// calls will return error.
//
//	body: func() -> result<outgoing-body>
//
//go:nosplit
func (self OutgoingResponse) Body() (result cm.Result[OutgoingBody, OutgoingBody, struct{}]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_OutgoingResponseBody((uint32)(self0), &result)
	return
}

// Headers represents the imported method "headers".
//
// Get the headers associated with the Request.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// This headers resource is a child: it must be dropped before the parent
// `outgoing-request` is dropped, or its ownership is transfered to
// another component by e.g. `outgoing-handler.handle`.
//
//	headers: func() -> headers
//
//go:nosplit
func (self OutgoingResponse) Headers() (result Headers) {
	self0 := cm.Reinterpret[uint32](self)
	result0 := wasmimport_OutgoingResponseHeaders((uint32)(self0))
	result = cm.Reinterpret[Headers]((uint32)(result0))
	return
}

// SetStatusCode represents the imported method "set-status-code".
//
// Set the HTTP Status Code for the Response. Fails if the status-code
// given is not a valid http status code.
//
//	set-status-code: func(status-code: status-code) -> result
//
//go:nosplit
func (self OutgoingResponse) SetStatusCode(statusCode StatusCode) (result cm.BoolResult) {
	self0 := cm.Reinterpret[uint32](self)
	statusCode0 := (uint32)(statusCode)
	result0 := wasmimport_OutgoingResponseSetStatusCode((uint32)(self0), (uint32)(statusCode0))
	result = (cm.BoolResult)(cm.U32ToBool((uint32)(result0)))
	return
}

// StatusCode represents the imported method "status-code".
//
// Get the HTTP Status Code for the Response.
//
//	status-code: func() -> status-code
//
//go:nosplit
func (self OutgoingResponse) StatusCode() (result StatusCode) {
	self0 := cm.Reinterpret[uint32](self)
	result0 := wasmimport_OutgoingResponseStatusCode((uint32)(self0))
	result = (StatusCode)((uint32)(result0))
	return
}

// OutgoingBody represents the imported resource "wasi:http/types@0.2.0#outgoing-body".
//
// Represents an outgoing HTTP Request or Response's Body.
//
// A body has both its contents - a stream of bytes - and a (possibly
// empty) set of trailers, inducating the full contents of the body
// have been sent. This resource represents the contents as an
// `output-stream` child resource, and the completion of the body (with
// optional trailers) with a static function that consumes the
// `outgoing-body` resource, and ensures that the user of this interface
// may not write to the body contents after the body has been finished.
//
// If the user code drops this resource, as opposed to calling the static
// method `finish`, the implementation should treat the body as incomplete,
// and that an error has occured. The implementation should propogate this
// error to the HTTP protocol by whatever means it has available,
// including: corrupting the body on the wire, aborting the associated
// Request, or sending a late status code for the Response.
//
//	resource outgoing-body
type OutgoingBody cm.Resource

// ResourceDrop represents the imported resource-drop for resource "outgoing-body".
//
// Drops a resource handle.
//
//go:nosplit
func (self OutgoingBody) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_OutgoingBodyResourceDrop((uint32)(self0))
	return
}

// OutgoingBodyFinish represents the imported static function "finish".
//
// Finalize an outgoing body, optionally providing trailers. This must be
// called to signal that the response is complete. If the `outgoing-body`
// is dropped without calling `outgoing-body.finalize`, the implementation
// should treat the body as corrupted.
//
// Fails if the body's `outgoing-request` or `outgoing-response` was
// constructed with a Content-Length header, and the contents written
// to the body (via `write`) does not match the value given in the
// Content-Length.
//
//	finish: static func(this: outgoing-body, trailers: option<trailers>) -> result<_,
//	error-code>
//
//go:nosplit
func OutgoingBodyFinish(this OutgoingBody, trailers cm.Option[Trailers]) (result cm.Result[ErrorCode, struct{}, ErrorCode]) {
	this0 := cm.Reinterpret[uint32](this)
	trailers0, trailers1 := lower_OptionTrailers(trailers)
	wasmimport_OutgoingBodyFinish((uint32)(this0), (uint32)(trailers0), (uint32)(trailers1), &result)
	return
}

// Write represents the imported method "write".
//
// Returns a stream for writing the body contents.
//
// The returned `output-stream` is a child resource: it must be dropped
// before the parent `outgoing-body` resource is dropped (or finished),
// otherwise the `outgoing-body` drop or `finish` will trap.
//
// Returns success on the first call: the `output-stream` resource for
// this `outgoing-body` may be retrieved at most once. Subsequent calls
// will return error.
//
//	write: func() -> result<output-stream>
//
//go:nosplit
func (self OutgoingBody) Write() (result cm.Result[OutputStream, OutputStream, struct{}]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_OutgoingBodyWrite((uint32)(self0), &result)
	return
}

// FutureIncomingResponse represents the imported resource "wasi:http/types@0.2.0#future-incoming-response".
//
// Represents a future which may eventaully return an incoming HTTP
// Response, or an error.
//
// This resource is returned by the `wasi:http/outgoing-handler` interface to
// provide the HTTP Response corresponding to the sent Request.
//
//	resource future-incoming-response
type FutureIncomingResponse cm.Resource

// ResourceDrop represents the imported resource-drop for resource "future-incoming-response".
//
// Drops a resource handle.
//
//go:nosplit
func (self FutureIncomingResponse) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_FutureIncomingResponseResourceDrop((uint32)(self0))
	return
}

// Get represents the imported method "get".
//
// Returns the incoming HTTP Response, or an error, once one is ready.
//
// The outer `option` represents future readiness. Users can wait on this
// `option` to become `some` using the `subscribe` method.
//
// The outer `result` is used to retrieve the response or error at most
// once. It will be success on the first call in which the outer option
// is `some`, and error on subsequent calls.
//
// The inner `result` represents that either the incoming HTTP Response
// status and headers have recieved successfully, or that an error
// occured. Errors may also occur while consuming the response body,
// but those will be reported by the `incoming-body` and its
// `output-stream` child.
//
//	get: func() -> option<result<result<incoming-response, error-code>>>
//
//go:nosplit
func (self FutureIncomingResponse) Get() (result cm.Option[cm.Result[cm.Result[ErrorCodeShape, IncomingResponse, ErrorCode], cm.Result[ErrorCodeShape, IncomingResponse, ErrorCode], struct{}]]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_FutureIncomingResponseGet((uint32)(self0), &result)
	return
}

// Subscribe represents the imported method "subscribe".
//
// Returns a pollable which becomes ready when either the Response has
// been received, or an error has occured. When this pollable is ready,
// the `get` method will return `some`.
//
//	subscribe: func() -> pollable
//
//go:nosplit
func (self FutureIncomingResponse) Subscribe() (result Pollable) {
	self0 := cm.Reinterpret[uint32](self)
	result0 := wasmimport_FutureIncomingResponseSubscribe((uint32)(self0))
	result = cm.Reinterpret[Pollable]((uint32)(result0))
	return
}

// HTTPErrorCode represents the imported function "http-error-code".
//
// Attempts to extract a http-related `error` from the wasi:io `error`
// provided.
//
// Stream operations which return
// `wasi:io/stream/stream-error::last-operation-failed` have a payload of
// type `wasi:io/error/error` with more information about the operation
// that failed. This payload can be passed through to this function to see
// if there's http-related information about the error to return.
//
// Note that this function is fallible because not all io-errors are
// http-related errors.
//
//	http-error-code: func(err: borrow<io-error>) -> option<error-code>
//
//go:nosplit
func HTTPErrorCode(err IOError) (result cm.Option[ErrorCode]) {
	err0 := cm.Reinterpret[uint32](err)
	wasmimport_HTTPErrorCode((uint32)(err0), &result)
	return
}
