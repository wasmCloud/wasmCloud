//! Macro for building [wasmCloud capability providers](https://wasmcloud.com/docs/fundamentals/capabilities/create-provider/)
//! from [WIT](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) contracts.
//!
//! For example, to build a capability provider for the [wasmcloud:keyvalue contract](https://github.com/wasmCloud/interfaces/tree/main/keyvalue):
//!
//! ```rust,ignore
//! wasmcloud_provider_wit_bindgen::generate!(
//!   KeyvalueProvider,      // implementation struct
//!   "wasmcloud:keyvalue",  // wasmcloud contract name
//!   "keyvalue",            // wit-bindgen style configuration
//! );
//!
//! struct YourProvider;
//! ```
//!
//! As is customary with WIT-related tooling, "keyvalue" refers to the WIT world that your component will inhabit. See [wit-bindgen tooling](https://github.com/bytecodealliance/wit-bindgen) for more information on the different forms that can be used.
//!

mod vendor;

use vendor::wasmtime_component_macro::bindgen::{expand as expand_wasmtime_component, Config};

use std::collections::HashMap;

use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::{Ident, Punct, Spacing, Span, TokenStream, TokenTree};
use quote::{format_ident, ToTokens, TokenStreamExt};
use syn::{
    parse::Parse,
    parse_macro_input, parse_quote,
    punctuated::Punctuated,
    visit_mut::{visit_item_mut, VisitMut},
    FnArg, Item, ItemMod, ItemStruct, LitStr, PathSegment, ReturnType, Token, TraitItem,
    TraitItemMethod,
};

/// Rust module name that is used by wit-bindgen to generate all the modules
const EXPORTS_MODULE_NAME: &str = "exports";

/// Name of the trait that is generated by wit-bindgen which includes all imported interfaces
const HOST_IMPORTS_TRAIT_NAME: &str = "Host";

type ImplStructName = String;
type StructName = String;
type WasmcloudContractName = String;
type WitNamespaceName = String;
type WitPackageName = String;
type WitInterfaceName = String;
type FullModulePath = String;
type StructLookup = HashMap<StructName, (Punctuated<PathSegment, Token![::]>, ItemStruct)>;

/// Inputs to the wit_bindgen_wasmcloud::provider::binary::generate! macro
struct MacroConfig {
    pub(crate) impl_struct: ImplStructName,
    pub(crate) contract: WasmcloudContractName,
    pub(crate) bindgen_cfg: Config,
}

impl Parse for MacroConfig {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let impl_struct: ImplStructName = input.parse::<syn::Ident>()?.to_string();
        input.parse::<Token![,]>()?;
        let contract: WasmcloudContractName = input.parse::<syn::LitStr>()?.value();
        input.parse::<Token![,]>()?;
        let bindgen_cfg = input.parse::<Config>()?;
        syn::Result::Ok(MacroConfig {
            impl_struct,
            contract,
            bindgen_cfg,
        })
    }
}

/// This macro generates functionality necessary to use a WIT-enabled Rust providers (binaries that are managed by the host)
#[proc_macro]
pub fn generate(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let cfg = parse_macro_input!(input as MacroConfig);
    let contract_ident = LitStr::new(cfg.contract.as_str(), Span::call_site());

    // Parse the WIT for files (a second time, in addition to what has been done to generate)
    let mut exported_iface_invocation_methods: Vec<TokenStream> = Vec::new();
    for (_, world) in cfg.bindgen_cfg.resolve.worlds.iter() {
        for (world_item, _) in world.exports.iter() {
            if let wit_parser::WorldKey::Interface(iface_id) = world_item {
                let iface = &cfg.bindgen_cfg.resolve.interfaces[*iface_id];

                // For each function in an exported interface,
                // we'll need to generate a method on the eventual InvocationHandler
                // that will be built later.
                //
                // We expect functions on exported interface to consist of *one* argument which is
                // normally a struct (WIT record type) what represents the information to be sent out on the lattice, ex.:
                //
                //  ```
                //  interface handler {
                //       use types.{some-message}
                //       handle-message: func(msg: some-message) -> result<_, string>
                //   }
                //  ```
                for (iface_fn_name, iface_fn) in iface.functions.iter() {
                    // Since we expect  inputs to the
                    let (arg_name, arg_rust_type): (&str, String) = match &iface_fn
                        .params
                        .as_slice()
                    {
                        [(arg_name, arg_type_raw)] => {
                            let rust_type = match arg_type_raw {
                                wit_parser::Type::Bool => "bool",
                                wit_parser::Type::U8 => "u8",
                                wit_parser::Type::U16 => "u16",
                                wit_parser::Type::U32 => "u32",
                                wit_parser::Type::U64 => "u64",
                                wit_parser::Type::S8 => "i8",
                                wit_parser::Type::S16 => "i16",
                                wit_parser::Type::S32 => "i32",
                                wit_parser::Type::S64 => "i64",
                                wit_parser::Type::Float32 => "f32",
                                wit_parser::Type::Float64 => "f64",
                                wit_parser::Type::Char => "char",
                                wit_parser::Type::String => "String",
                                wit_parser::Type::Id(tydef) => {
                                    let type_def = &cfg.bindgen_cfg.resolve.types[*tydef];
                                    if let Some(name) = &type_def.name {
                                        name.as_str()
                                    } else {
                                        panic!(
                                            r#"
Un-named type detected on argument while parsing interface [{}].
Please ensure that types for exported interface functions (normally a single record type representing a message to be sent on the lattice) are specified.
"#,
                                            iface.name.clone().unwrap_or("<unknown>".into()),
                                        )
                                    }
                                }
                            };

                            // At this point we know there's actually only one
                            (arg_name, rust_type.to_upper_camel_case())
                        }
                        // Currently, interface functions are only allowed to accept
                        // a single parameter, normally a record, which represent a message to be sent out on the lattice
                        _ => {
                            panic!(
                                r#"
Functions on exported interfaces must only accept one argument, normally a a record type that can be sent
out on the lattice. Please modify the corresponding WIT file that contains interface [{}]
"#,
                                iface.name.clone().unwrap_or("<unknown>".into())
                            );
                        }
                    };

                    let fn_name =
                        Ident::new(iface_fn_name.to_snake_case().as_str(), Span::call_site());

                    let lattice_method = LitStr::new(
                        format!("Message.{}", iface_fn_name.to_upper_camel_case()).as_str(),
                        Span::call_site(),
                    );

                    let arg_name_ident = Ident::new(arg_name, Span::call_site());
                    let arg_type_ident = Ident::new(arg_rust_type.as_str(), Span::call_site());

                    // Augment the list of invocation methods that have to be fulfilled
                    exported_iface_invocation_methods.push(quote::quote!(
                        async fn #fn_name(
                            &self,
                            #arg_name_ident: #arg_type_ident,
                        ) -> Result<(), ::wasmcloud_provider_sdk::error::ProviderInvocationError> {
                            let connection = ::wasmcloud_provider_sdk::provider_main::get_connection();
                            let client = connection.get_rpc_client();
                            let response = client
                                .send(
                                    ::wasmcloud_core::WasmCloudEntity {
                                        public_key: self.ld.provider_id.clone(),
                                        link_name: self.ld.link_name.clone(),
                                        contract_id: #contract_ident.to_string(),
                                    },
                                    ::wasmcloud_core::WasmCloudEntity {
                                        public_key: self.ld.actor_id.clone(),
                                        ..Default::default()
                                    },
                                    #lattice_method,
                                    ::wasmcloud_provider_sdk::serialize(&#arg_name_ident)?,
                                )
                                .await?;

                            if let Some(err) = response.error {
                                // Please note that all errors used should implement ToString in order for this to work
                                Err(::wasmcloud_provider_sdk::error::ProviderInvocationError::Provider(
                                    err.to_string(),
                                ))
                            } else {
                                Ok(())
                            }
                        }
                    ));
                }
            }
        }
    }

    // Expand the wasmtime::component macro with the given arguments
    let bindgen_tokens: TokenStream =
        expand_wasmtime_component(&cfg.bindgen_cfg).unwrap_or_else(syn::Error::into_compile_error);

    // Parse the bindgen-generated tokens into an AST
    let mut bindgen_ast: syn::File =
        syn::parse2(bindgen_tokens).expect("failed to parse wit-bindgen generated code as file");

    // Visit the code that has been generated, to extract information we'll need to modify it
    let mut visitor = WitBindgenOutputVisitor::default();
    visitor.visit_file_mut(&mut bindgen_ast);

    // Turn the function calls into object declarations for receiving from lattice
    let methods_by_iface = match (&visitor.wit_ns, &visitor.wit_package) {
        (Some(ns), Some(package)) => build_lattice_methods_by_wit_interface(
            &visitor.serde_extended_structs,
            &visitor.import_trait_methods,
            ns,
            package,
        ),
        _ => panic!("failed to parse top-level WIT package name while reading bindgen output"),
    };

    // Create the implementation struct name as an Ident
    let impl_struct_name = Ident::new_raw(cfg.impl_struct.as_str(), Span::call_site());

    // Build a list of match arms for the interfaces
    let mut interface_dispatch_match_arms: Vec<TokenStream> = Vec::new();

    let mut iface_tokens = TokenStream::new();
    for (wit_iface_name, methods) in methods_by_iface.iter() {
        let wit_iface = Ident::new(wit_iface_name, Span::call_site());

        // Build collections to be iterated over during codegen
        let struct_names = methods
            .clone()
            .into_iter()
            .map(|LatticeMethod { struct_name, .. }| struct_name)
            .collect::<Vec<proc_macro2::Ident>>();
        let struct_members = methods
            .clone()
            .into_iter()
            .map(|LatticeMethod { struct_members, .. }| struct_members)
            .collect::<Vec<TokenStream>>();
        let lattice_method_names = methods
            .clone()
            .into_iter()
            .map(
                |LatticeMethod {
                     lattice_method_name,
                     ..
                 }| lattice_method_name,
            )
            .collect::<Vec<LitStr>>();
        let func_names = methods
            .clone()
            .into_iter()
            .map(|LatticeMethod { func_name, .. }| func_name)
            .collect::<Vec<Ident>>();
        let invocation_args = methods
            .clone()
            .into_iter()
            .map(
                |LatticeMethod {
                     invocation_args, ..
                 }| invocation_args,
            )
            .collect::<Vec<Vec<Ident>>>();
        let invocation_returns = methods
            .clone()
            .into_iter()
            .map(
                |LatticeMethod {
                     invocation_return, ..
                 }| invocation_return,
            )
            .collect::<Vec<ReturnType>>();

        // Add the structs for the current interface
        iface_tokens.append_all(quote::quote!(
            // START: *Invocation structs & trait for #wit_iface
            #(
                #[derive(Debug, ::serde::Serialize, ::serde::Deserialize)]
                struct #struct_names {
                    #struct_members
                }
            )*

            #[::async_trait::async_trait]
            pub trait #wit_iface {
                fn contract_id() -> &'static str {
                    #contract_ident
                }

                #(
                    async fn #func_names (
                        &self,
                        ctx: ::wasmcloud_provider_sdk::Context,
                        #struct_members,
                    ) #invocation_returns;
                )*
            }
            // END: *Invocation structs & trait for #wit_iface
        ));

        // After building individual invocation structs and traits for each interface
        // we must build & hold on to the usage of these inside the match for the MessageDispatch trait
        interface_dispatch_match_arms.push(quote::quote!(
            #(
                #lattice_method_names => {
                    let input: #struct_names = ::wasmcloud_provider_sdk::deserialize(&body)?;
                    let result = #wit_iface::#func_names(
                        self,
                        ctx,
                        #(
                            input.#invocation_args,
                        )*
                    )
                        .await
                        .map_err(|e| {
                            ::wasmcloud_provider_sdk::error::ProviderInvocationError::Provider(e.to_string())
                        })?;
                    Ok(::wasmcloud_provider_sdk::serialize(&result)?)
                }
            )*
        ));
    }

    // Build a list of structs that should be included
    let structs: Vec<TokenStream> = visitor
        .serde_extended_structs
        .iter()
        .map(|(_, (_, s))| s.to_token_stream())
        .collect();

    // Build the final chunk of code
    let tokens = quote::quote!(
        // START: per-interface codegen
        #iface_tokens
        // END: per-interface codegen

        // START: wit-bindgen generated structs to map types
        #(
            #structs
        )*
        // END: wit-bindgen generated structs to map types

        /// MessageDispatch ensures that your provider can receive and
        /// process messages sent to it over the lattice
        ///
        /// This implementation is a stub and must be filled out by implementers
        ///
        /// It would be preferable to use <T: SomeTrait> here, but the fact that  'd like to use
        #[::async_trait::async_trait]
        impl ::wasmcloud_provider_sdk::MessageDispatch for #impl_struct_name {
            async fn dispatch<'a>(
                &'a self,
                ctx: ::wasmcloud_provider_sdk::Context,
                method: String,
                body: std::borrow::Cow<'a, [u8]>,
            ) -> Result<Vec<u8>, ::wasmcloud_provider_sdk::error::ProviderInvocationError> {
                match method.as_str() {
                    #(
                        #interface_dispatch_match_arms
                    )*
                    _ => Err(::wasmcloud_provider_sdk::error::InvocationError::Malformed(format!(
                        "Invalid method name {method}",
                    ))
                             .into()),
                }
            }
        }

        // START: general provider

        /// This trait categorizes all wasmCloud lattice compatible providers.
        ///
        /// It is a mirror of ProviderHandler for the purposes of ensuring that
        /// at least the following members are is supported.
        #[::async_trait::async_trait]
        trait WasmcloudCapabilityProvider {
            async fn put_link(&self, ld: &::wasmcloud_core::LinkDefinition) -> bool;
            async fn delete_link(&self, actor_id: &str);
            async fn shutdown(&self);
        }

        /// ProviderHandler ensures that your provider handles the basic
        /// required functionality of all Providers on a wasmCloud lattice.
        ///
        /// This implementation is a stub and must be filled out by implementers
        #[::async_trait::async_trait]
        impl ::wasmcloud_provider_sdk::ProviderHandler for #impl_struct_name {
            async fn put_link(&self, ld: &::wasmcloud_core::LinkDefinition) -> bool {
                WasmcloudCapabilityProvider::put_link(self, ld).await
            }

            async fn delete_link(&self, actor_id: &str) {
                WasmcloudCapabilityProvider::delete_link(self, actor_id).await
            }

            async fn shutdown(&self) {
                WasmcloudCapabilityProvider::shutdown(self).await
            }
        }

        /// Given the implementation of ProviderHandler and MessageDispatch,
        /// the implementation for your struct is a guaranteed
        impl ::wasmcloud_provider_sdk::Provider for #impl_struct_name {}

        /// This handler serves to be used for individual invocations of the actor
        /// as performed by the host runtime
        ///
        /// Interfaces exported by the provider can use this to send traffic across the lattice
        pub struct InvocationHandler<'a> {
            ld: &'a ::wasmcloud_core::LinkDefinition,
        }

        impl<'a> InvocationHandler<'a> {
            pub fn new(ld: &'a ::wasmcloud_core::LinkDefinition) -> Self {
                Self { ld }
            }

            #(
                #exported_iface_invocation_methods
            )*
        }

    );

    tokens.into()
}

/// A struct for visiting the output of wit-bindgen
/// focused around gathering all the important declarations we care about
#[derive(Default)]
struct WitBindgenOutputVisitor {
    /// The detected namespace of the WIT file
    wit_ns: Option<WitNamespaceName>,

    /// The detected package of the WIT file
    wit_package: Option<WitPackageName>,

    /// Parents of the current module being traversed
    parents: Vec<Ident>,

    /// Top level module that does contains all WIT exports
    /// normally with internal modules starting from namespace
    /// ex. ('exports' -> <WIT namespace> -> <WIT pkg>)
    exports_ns_module: Option<ItemMod>,

    /// Structs that were modified and extended to derive Serialize/Deserialize
    serde_extended_structs: StructLookup,

    /// Functions in traits that we'll have to stub eventually
    import_trait_methods: HashMap<WitInterfaceName, Vec<TraitItemMethod>>,
}

impl WitBindgenOutputVisitor {
    /// Check if a given string is the same as the top-level WIT namespace that was detected
    fn is_wit_ns(&self, s: impl AsRef<str>) -> bool {
        if let Some(v) = &self.wit_ns {
            v == s.as_ref()
        } else {
            false
        }
    }

    /// Check the distance of the current module from crate/generated wit-bindgen content root
    fn current_module_level(&self) -> usize {
        self.parents.len()
    }

    /// Get the full path to the current module
    /// ex. (`<namespace>::<package>::some::wit::interface`)
    fn current_module_full_path(&self) -> FullModulePath {
        self.parents
            .iter()
            .map(|i| i.to_string())
            .collect::<Vec<String>>()
            .join(",")
    }

    /// Check whether a the current node is directly under the wasm namespace
    /// Primarily used for detecting the package
    /// i.e. '<ns>/<package>'
    fn at_wit_ns_module_child(&self) -> bool {
        self.parents
            .last()
            .is_some_and(|ps| self.is_wit_ns(ps.to_string()))
    }

    /// Check whether the direct parent has a given name value
    fn at_child_of_module(&self, name: impl AsRef<str>) -> bool {
        self.parents.last().is_some_and(|v| v == name.as_ref())
    }

    /// Check whether we are currently at a module *below* the 'exports' known module name
    fn at_exported_module(&self) -> bool {
        self.parents.iter().any(|v| v == EXPORTS_MODULE_NAME)
    }
}

impl VisitMut for WitBindgenOutputVisitor {
    fn visit_item_mod_mut(&mut self, node: &mut ItemMod) {
        // Save the WIT namespace that we've recognized
        //
        // The top level WIT namespace is always a module at @ level zero
        // of the item hierarchy in packages with imports, but is @ level 1 in packages
        // with only exports
        if (self.current_module_level() == 0 && node.ident != EXPORTS_MODULE_NAME)
            || (self.current_module_level() == 1 && self.at_exported_module())
        {
            self.wit_ns = Some(node.ident.to_string());
        }

        // Save the WIT package name
        //
        // In packages with imports, the package name will be at level 1 (under the ns)
        // but in packages with only exports, it will be at level 2 under 'exports' and the ns)
        if (
            self.current_module_level() == 1
            && self.at_wit_ns_module_child()
            && !self.at_exported_module())
            // Exports only case
            || (self.current_module_level() == 2 && self.at_exported_module())
        {
            self.wit_package = Some(node.ident.to_string());
        }

        // Recognize the 'exports' module which contains
        // all the exported interfaces
        //
        // ASSUMPTION: all exported modules are put into a level 0 'exports' module
        // which contains the top level namespace again
        if self.current_module_level() == 1 && self.at_child_of_module(EXPORTS_MODULE_NAME) {
            // this would be the ('exports' -> <ns>) node, note 'exports' itself.
            self.exports_ns_module = Some(node.clone());
        }

        // ASSUMPTION: level 2 modules contain externally visible *or* used interfaces
        // (i.e. ones that are exported)
        // 'use' calls will  cause an interface to show up, but only if the
        // thing that uses it is imported/exported

        // Recur/Traverse deeper into the detected modules where possible
        if let Some((_, ref mut items)) = &mut node.content {
            // Save the current module before we go spelunking
            self.parents.push(node.ident.clone());

            for item in items {
                self.visit_item_mut(item);
            }

            self.parents.pop();
        }
    }

    fn visit_item_mut(&mut self, node: &mut syn::Item) {
        match node {
            Item::Trait(t) => {
                // Host traits are generated for interfaces that are imported by the host, and generally
                // must have traits created that are *similar*, but asynchronous in nature.
                //
                // In general, messages in host traits become RPC calls that go out on the lattice, so they must be converted
                if t.ident == HOST_IMPORTS_TRAIT_NAME {
                    for ti in t.items.iter_mut() {
                        if let TraitItem::Method(tim) = ti {
                            // Prune the &self argument
                            let mut trimmed = tim.clone();
                            trimmed.sig.inputs = <Punctuated<FnArg, Token![,]>>::from_iter(
                                trimmed.sig.inputs.into_iter().skip(1),
                            );

                            // Convert wasmtime:Result<T, wasmtime::Error> -> T
                            match &mut trimmed
                                .sig
                                .output
                                .to_token_stream()
                                .into_iter()
                                .collect::<Vec<TokenTree>>()[..]
                            {
                                [
                                    TokenTree::Punct(_), // -
                                    TokenTree::Punct(_), // >
                                    TokenTree::Ident(ref w), // wasmtime
                                    TokenTree::Punct(_), // :
                                    TokenTree::Punct(_), // :
                                    TokenTree::Ident(ref r), // Result
                                    TokenTree::Punct(_), // <
                                    inner @ ..,
                                    TokenTree::Punct(_), // >
                                ] if w == "wasmtime" && r == "Result" => {
                                    let mut inner_tokens = TokenStream::new();
                                    inner.iter_mut().fold(&mut inner_tokens, |acc, v| {
                                        acc.append(v.clone());
                                        acc
                                    });
                                    let result_tokens = quote::quote!(
                                            -> ::wasmcloud_provider_sdk::error::ProviderResult<#inner_tokens>
                                        );

                                        trimmed.sig.output = syn::parse2::<ReturnType>(result_tokens).expect("failed to purge wasmtime::Result from method return");

                                    },
                                    _ => {},
                                }

                            // Find functions in traits that we must stub later
                            self.import_trait_methods
                                .entry(self.current_module_full_path())
                                .or_default()
                                .push(trimmed);
                        }
                    }
                }
            }

            Item::Struct(s) => {
                // If this is a generated struct (from a WIT record), add serde Serialize/eDeserialize
                //
                // exclude exported modules since they contain wasmtime::component::Func, which cannot be Serialized
                // exclude top level structs, since they indirectly include the exported module
                if self.current_module_level() != 0
                    && !self.at_exported_module()
                    && !self
                        .serde_extended_structs
                        .contains_key(&s.ident.to_string())
                {
                    // Clear all pre-existing attributes (i.e. [component])
                    s.attrs.clear();

                    // Clear all pre-existing attributes from fields (mostly [component])
                    for f in &mut s.fields {
                        f.attrs.clear();
                    }

                    // Add the attributes we want to be present
                    s.attrs.append(&mut vec![parse_quote!(
                        #[derive(Debug, ::serde::Serialize, ::serde::Deserialize)]
                    )]);

                    // Save the Struct by name to the tally of structs that have been extended
                    // this is used later to generate interfaces, when generating interfaces, as a import path lookup
                    // so that types can be resolved (i.e. T -> path::to::T)
                    let mut struct_import_path = Punctuated::<syn::PathSegment, Token![::]>::new();
                    for p in self.parents.iter() {
                        struct_import_path.push(syn::PathSegment::from(p.clone()));
                    }
                    struct_import_path.push(syn::PathSegment::from(s.ident.clone()));

                    // Disallow the case where two identically named structs exist under different paths
                    if self
                        .serde_extended_structs
                        .contains_key(&s.ident.to_string())
                    {
                        panic!("found duplicate instances of struct [${}]", s.ident);
                    }

                    self.serde_extended_structs
                        .insert(s.ident.to_string(), (struct_import_path, s.clone()));
                }
            }

            _ => visit_item_mut(self, node),
        }
    }
}

#[derive(Debug, Clone)]
struct LatticeMethod {
    /// The name of the method that would be used on the lattice
    lattice_method_name: LitStr,
    /// The name of the struct that can be deserialized to perform the invocation
    struct_name: Ident,
    /// Tokens that represent the struct member declarations
    struct_members: TokenStream,
    /// Function name for the method that will be called after a lattice invocation is received
    func_name: Ident,
    /// Invocation arguments (i.e. invocation struct members)
    invocation_args: Vec<Ident>,
    /// Invocation arguments (i.e. invocation struct members)
    invocation_return: ReturnType,
}

fn build_lattice_methods_by_wit_interface(
    struct_lookup: &StructLookup,
    map: &HashMap<WitInterfaceName, Vec<TraitItemMethod>>,
    wit_ns: &str,
    wit_package: &str,
) -> HashMap<WitInterfaceName, Vec<LatticeMethod>> {
    let mut methods_by_name: HashMap<WitInterfaceName, Vec<LatticeMethod>> = HashMap::new();

    // Per module import we must build up a different structs
    for (wit_iface_name, funcs) in map.iter() {
        for f in funcs.iter() {
            // Create an identifier for the new struct that will represent the function invocation coming
            // across the lattice, in a <CamelCaseModule><CamelCaseInterface><CamelCaseFunctionName> pattern
            // (ex. MessagingConsumerRequestMultiInvocation)
            let lattice_method_name = LitStr::new(
                format!(
                    "{}{}/Message.{}",
                    wit_ns,
                    wit_package,
                    f.sig.ident.to_string().to_upper_camel_case()
                )
                .as_ref(),
                Span::call_site(),
            );

            // Build the name of the invocation struct
            let struct_name = format_ident!(
                "{}{}Invocation",
                wit_iface_name.to_upper_camel_case(),
                f.sig.ident.to_string().to_upper_camel_case()
            );

            // Build a list of invocation arguments similar to the structs
            let mut invocation_args: Vec<Ident> = Vec::new();

            // Transform the members and remove any lifetimes by manually converting references to owned data
            // (i.e. doing things like converting a type like &str to String mechanically)
            let struct_members = f
                .sig
                // Get all function inputs for the function signature
                .inputs
                .iter()
                .enumerate()
                .fold(TokenStream::new(), |mut tokens, (idx, arg)| {
                    // If we're not the first index, add a comman
                    if idx != 0 {
                        tokens.append_all([&TokenTree::Punct(Punct::new(',', proc_macro2::Spacing::Alone))]);
                    }

                    // Match on a single input argument in the function signature
                    match &arg
                            .to_token_stream()
                            .into_iter()
                            .collect::<Vec<TokenTree>>()[..]
                        {
                            // pattern: 'name: &T'
                            simple_ref @ &[
                                TokenTree::Ident(ref n), // name
                                TokenTree::Punct(_), // :
                                TokenTree::Punct(ref p), // &
                                TokenTree::Ident(ref t), // T
                            ] if p.as_char() == '&' => {
                                // Save the invocation argument for later
                                invocation_args.push(n.clone());

                                // Match the type that came out of the simple case
                                match t.to_string().as_str() {
                                    // A &str
                                    "str" => {
                                        tokens.append_all([
                                            &simple_ref[0],
                                            &simple_ref[1],
                                            // replace the type with an owned string
                                            &TokenTree::Ident(Ident::new("String", t.span())),
                                        ]);
                                    },

                                    // Unexpected non-standard type as reference
                                    // (likely a known custom type generated by wit-bindgen)
                                    _ => {

                                        // Add a modified group of tokens to the list for the struct
                                        tokens.append_all([
                                            &simple_ref[0], // name
                                            &simple_ref[1], // colon
                                        ]);

                                        // If we have a T that this module defined, we must use the full path to it
                                        // if not, it is likely a builtin, so we can use it directly
                                        if let Some((v, _)) = struct_lookup.get(&simple_ref[3].to_string()) {
                                            tokens.append_all([ v.to_token_stream() ]);
                                        } else {
                                            tokens.append_all([ &simple_ref[3]]);
                                        };
                                    }
                                }
                            },

                            // pattern: 'name: Wrapper<&T>'
                            wrapped_ref @ &[
                                TokenTree::Ident(ref n),  // name
                                TokenTree::Punct(_),  // :
                                TokenTree::Ident(_),  // Wrapper
                                TokenTree::Punct(ref p),  // <
                                TokenTree::Punct(ref p2), // &
                                ..,  // T
                                TokenTree::Punct(_) // >
                            ] if p.as_char() == '<' && p2.as_char() == '&' => {
                                // Save the invocation argument for later
                                invocation_args.push(n.clone());

                                // Slice out the parts in between the < ... >
                                let type_section = &wrapped_ref[4..wrapped_ref.len()];

                                match type_section {
                                    // case: str
                                    [
                                        TokenTree::Punct(_), // <
                                        TokenTree::Ident(ref n),
                                        TokenTree::Punct(_) // >
                                    ] if n.to_string().as_str() == "str" => {
                                        tokens.append_all([
                                            &wrapped_ref[0], // name
                                            &wrapped_ref[1], // colon
                                            &wrapped_ref[2], // wrapper
                                            &wrapped_ref[3], // <
                                            &TokenTree::Ident(Ident::new("String", n.span())),
                                            &wrapped_ref[5], // >
                                        ]);
                                    },

                                    // case: [u8]
                                    [
                                        TokenTree::Punct(_), // <
                                        TokenTree::Group(g),
                                        TokenTree::Punct(_), // >
                                    ] if g.to_string().as_str() == "[u8]" => {
                                        tokens.append_all([
                                            &wrapped_ref[0], // name
                                            &wrapped_ref[1], // colon
                                            &wrapped_ref[2], // wrapper
                                            &wrapped_ref[3], // <
                                            &TokenTree::Ident(Ident::new("Vec", Span::call_site())), // Vec
                                            &TokenTree::Punct(Punct::new('<', Spacing::Joint)), // <
                                            &TokenTree::Ident(Ident::new("u8", Span::call_site())), // u8
                                            &TokenTree::Punct(Punct::new('>', Spacing::Joint)), // >
                                            &TokenTree::Punct(Punct::new('>', Spacing::Joint)), // >
                                        ]);
                                    },

                                    rest =>  {
                                        // If we have a < T >, and T is a struct this module defined, we must use the full path to it
                                        // if not, it is likely a builtin, so we can use it directly
                                        if let Some((v, _)) = struct_lookup.get(&rest[1].to_string()) {
                                            tokens.append_all(&wrapped_ref[0..5]);
                                            tokens.append_all([ v.to_token_stream() ]);
                                            tokens.append_all(&wrapped_ref[6..]);
                                        } else {
                                            tokens.append_all(wrapped_ref);
                                        };
                                    },
                                }
                            },

                            // pattern: unknown
                            ts => {
                                // Save the first token (which should be the argument name) as an invocation argument for later
                                if let TokenTree::Ident(name) = &ts[0] {
                                    invocation_args.push(name.clone());
                                }

                                tokens.append_all(ts);
                            }
                        }

                    tokens
                });

            // Remove wasmtime::Error from methods on the output

            // Add the struct and it's members to a list that will be used in another quote
            // it cannot be added directly/composed to a TokenStream here to avoid import conflicts
            // in case bindgen-defined types are used.
            methods_by_name
                .entry(wit_iface_name.to_string().to_upper_camel_case())
                .or_default()
                .push(LatticeMethod {
                    lattice_method_name,
                    struct_name,
                    struct_members,
                    func_name: f.sig.ident.clone(),
                    invocation_args,
                    invocation_return: f.sig.output.clone(),
                });
        }
    }
    methods_by_name
}
