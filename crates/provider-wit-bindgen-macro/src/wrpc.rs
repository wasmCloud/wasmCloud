//! wRPC related functionality
//!

use anyhow::{Context, Result};
use wit_parser::Resolve;

/// Human readable name of a [`wit_parser::WorldKey`] which includes interface ID if necessary
/// see: https://docs.rs/wit-parser/latest/wit_parser/struct.Resolve.html#method.name_world_key
type WorldKeyName = String;

/// WIT function name
type WitFunctionName = String;

/// A struct to hold information on exports that should be use with wRPC
/// this information is normally used to construct macro output
pub(crate) struct WrpcExport {
    pub(crate) wit_ns: String,
    pub(crate) wit_pkg: String,
    pub(crate) wit_iface: String,
    pub(crate) wit_iface_fn: String,
    /// Information generated by wrpc_types
    pub(crate) types: (
        WorldKeyName,
        WitFunctionName,
        Vec<u8>, // TODO: replace w/ wrpc_types::DynamicFunction
    ),
}

/// Generate a list of [`WrpcExport`] which will be used to generate incoming NATS RPC subjects
/// on which the provider should listen.
pub(crate) fn generate_wrpc_nats_subject_to_fn_mapping(
    resolve: &Resolve,
) -> Result<Vec<WrpcExport>> {
    let mut subjects = Vec::new();

    for (_, world) in resolve.worlds.iter() {
        // Generate a lookup of all dynamic functions for this world export
        // TODO: use real wrpc_types lookup
        // let wrpc_type_lookup = wrpc_types::function_exports(&resolve, world.exports.iter());

        // We need to also go through the exports in order to generate the
        for (world_item, _) in world.exports.iter() {
            match world_item {
                wit_parser::WorldKey::Name(_) => continue,
                wit_parser::WorldKey::Interface(iface_id) => {
                    let iface = resolve.interfaces.get(*iface_id).with_context(|| {
                        format!("unexpectedly missing iface with ID [{iface_id:?}]")
                    })?;

                    let iface_name = iface.name.as_ref().with_context(|| {
                        format!(
                            "unexpectedly un-named iface ID [{iface_id:?}] in world [{}]",
                            &world.name,
                        )
                    })?;

                    let iface_pkg = resolve
                        .packages
                        .get(iface.package.with_context(|| {
                            format!("unexpectedly missing package for iface [{iface_name}] ")
                        })?)
                        .with_context(|| {
                            "missing top level referenced package for iface [{iface_name}]"
                        })?;
                    let ns = &iface_pkg.name.namespace;
                    let pkg_name = &iface_pkg.name.name;

                    for (fn_name, _) in iface.functions.iter() {
                        let world_key_name = resolve.name_world_key(&world_item);
                        // TODO: REPLACE this with real wrpc_type lookup
                        //
                        // let dynamic_fn = wrpc_type_lookup
                        //     .get(world_key_name)
                        //     .and_then(|lookup| lookup.get(fn_name));
                        subjects.push(WrpcExport {
                            wit_ns: ns.into(),
                            wit_pkg: pkg_name.into(),
                            wit_iface: iface_name.into(),
                            wit_iface_fn: fn_name.into(),
                            types: (world_key_name, fn_name.into(), Vec::new()), // TODO: change this to wrpc_type
                        });
                    }
                }
            }
        }
    }
    Ok(subjects)
}
