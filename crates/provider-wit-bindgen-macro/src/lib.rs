//! Macro for building [wasmCloud capability providers](https://wasmcloud.com/docs/fundamentals/capabilities/create-provider/)
//! from [WIT](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) contracts.
//!
//! For example, to build a capability provider for the [wasmcloud:keyvalue contract](https://github.com/wasmCloud/interfaces/tree/main/keyvalue):
//!
//! ```rust,ignore
//! wasmcloud_provider_wit_bindgen::generate!({
//!     impl_struct: KvRedisProvider,
//!     contract: "wasmcloud:keyvalue",
//!     wit_bindgen_cfg: "provider-kvredis"
//! });
//!
//! struct YourProvider;
//! ```
//!
//! All content after `wit_bindgen_cfg: ` is fed to the underlying bindgen (wasmtime::component::macro). In this example, "provider-kvredis" refers to the WIT world that your component will inhabit -- expected to be found at `<project root>/wit/<your world name>.wit`. An example world file:
//!
//! ```rust,ignore
//! package wasmcloud:provider-kvredis
//!
//! world provider-kvredis {
//!     import wasmcloud:keyvalue/key-value
//! }
//! ```
//!
//! For more information on the options available to underlying bindgen, see the [wasmtime-component-bindgen documentation](https://docs.rs/wasmtime/latest/wasmtime/component/macro.bindgen.html).
//!

use std::{collections::HashMap, str::FromStr};

use anyhow::{bail, ensure, Context};
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::{Ident, Punct, Spacing, Span, TokenStream, TokenTree};
use quote::{format_ident, ToTokens, TokenStreamExt};
use syn::{
    braced, bracketed,
    parse::Parse,
    parse_macro_input, parse_quote,
    punctuated::Punctuated,
    visit_mut::{visit_item_mut, VisitMut},
    FnArg, Item, ItemEnum, ItemMod, ItemStruct, ItemType, LitStr, PathSegment, ReturnType, Token,
    TraitItem, TraitItemFn, Type,
};
use tracing::{debug, trace, warn};
use tracing_subscriber::EnvFilter;

mod vendor;
use vendor::wasmtime_component_macro::bindgen::{
    expand as expand_wasmtime_component, Config as WitBindgenConfig,
};
use wit_parser::{Handle, Result_, Stream, Tuple, TypeDefKind};

/// Rust module name that is used by wit-bindgen to generate all the modules
const EXPORTS_MODULE_NAME: &str = "exports";

/// Name of the trait that is generated by wit-bindgen which includes all imported interfaces
const HOST_IMPORTS_TRAIT_NAME: &str = "Host";

type ImplStructName = String;
type WitNamespaceName = String;
type WitPackageName = String;
/// '.' delimited module path to an existing WIT interface (ex. 'wasmcloud.keyvalue.key_value')
type WitInterfacePath = String;
type WitFunctionName = String;
type FullModulePath = String;
type WasmcloudContract = String;
type LatticeExposedInterface = (WitNamespaceName, WitPackageName, WitFunctionName);

type StructName = String;
type StructLookup = HashMap<StructName, (Punctuated<PathSegment, Token![::]>, ItemStruct)>;

type EnumName = String;
type EnumLookup = HashMap<EnumName, (Punctuated<PathSegment, Token![::]>, ItemEnum)>;

type TypeName = String;
type TypeLookup = HashMap<TypeName, (Punctuated<PathSegment, Token![::]>, ItemType)>;

type FunctionTokenStream = TokenStream;
type StructTokenStream = TokenStream;

/// Inputs to the wit_bindgen_wasmcloud::provider::binary::generate! macro
struct ProviderBindgenConfig {
    /// The struct that will contain the implementation of the provider
    pub(crate) impl_struct: ImplStructName,

    /// The wasmCloud contract that the provider fulfills
    pub(crate) contract: WasmcloudContract,

    /// WIT namespace of the provider WIT
    pub(crate) wit_ns: Option<WitNamespaceName>,

    /// WIT package of the provider
    pub(crate) wit_pkg: Option<WitPackageName>,

    /// Interfaces that will be exposed onto the lattice.
    /// If left empty, all available interfaces will be exposed
    pub(crate) exposed_interface_allow_list: Vec<LatticeExposedInterface>,

    /// Interfaces that must explicitly not be exposed onto the lattice
    pub(crate) exposed_interface_deny_list: Vec<LatticeExposedInterface>,

    /// wit-bindgen configuration that is passed straight through (uses vendored wit-bindgen)
    ///
    /// During an actual parse run, configuration to pass through to wit bindgen *must* be provided
    /// this means that full parse runs can only be run when you can set up the filesystem as necessary.
    ///
    /// This allows local tests to easily generate `ProviderBindgenConfig` objects, without building the
    /// file tree (and related WIT) that wit-bindgen would attempt to read
    pub(crate) wit_bindgen_cfg: Option<WitBindgenConfig>,

    /// Translation strategy for functions on imported interfaces when generating lattice data structures and code
    pub(crate) import_fn_lattice_translation_strategy: WitFunctionLatticeTranslationStrategy,

    /// Translation strategy for functions on exported interfaces when generating lattice data structures and code
    pub(crate) export_fn_lattice_translation_strategy: WitFunctionLatticeTranslationStrategy,

    /// Whether to replace WIT-ified maps (`list<tuple<T, T>>`) with a Map type (`std::collections::HashMap`)
    pub(crate) replace_witified_maps: bool,
}

/// Keywords that are used by this macro
mod keywords {
    syn::custom_keyword!(contract);
    syn::custom_keyword!(wit_namespace);
    syn::custom_keyword!(wit_package);
    syn::custom_keyword!(impl_struct);
    syn::custom_keyword!(wit_bindgen_cfg);
    syn::custom_keyword!(import_fn_lattice_translation_strategy);
    syn::custom_keyword!(export_fn_lattice_translation_strategy);
    syn::custom_keyword!(exposed_interface_allow_list);
    syn::custom_keyword!(exposed_interface_deny_list);
    syn::custom_keyword!(replace_witified_maps);
}

/// Wrapper for a list of qualified WIT function names
#[derive(Debug, Default)]
struct WitFnList {
    inner: Vec<LatticeExposedInterface>,
}

impl From<WitFnList> for Vec<LatticeExposedInterface> {
    fn from(value: WitFnList) -> Self {
        value.inner
    }
}

impl Parse for WitFnList {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut inner = Vec::new();
        let names;
        bracketed!(names in input);
        let fns = Punctuated::<LitStr, Token![,]>::parse_terminated(&names)?;
        for name_ident in fns {
            let name = name_ident.value();
            let mut split = name.split(':');
            let ns = split.next();
            let package_iface = split.next().and_then(|rhs| rhs.split_once('/'));
            match (ns, package_iface) {
                (Some(ns), Some((pkg, fn_name))) => {
                    debug!("successfully parsed interface {ns}:{pkg}/{fn_name}");
                    inner.push((ns.into(), pkg.into(), fn_name.into()));
                }
                _ => {
                    return syn::Result::Err(
                        syn::Error::new(
                            Span::call_site(),
                            format!("allow/deny list entries must be of the form \"<ns>:<package>/<interface>\", failed to process [\"{name}\"]")
                        )
                    );
                }
            }
        }
        Ok(Self { inner })
    }
}

/// Options that can be used to perform bindgen
#[allow(clippy::large_enum_variant)]
enum ProviderBindgenConfigOption {
    /// Wasmcloud contract that should be the generated provider
    Contract(syn::LitStr),

    /// Struct that will implement the WIT world
    ImplStruct(syn::Ident),

    /// WIT namespace name
    WitNamespace(syn::LitStr),

    /// WIT package name
    WitPackage(syn::LitStr),

    /// Wit Bindgen configuration (mostly passed on directly to vendored bindgen)
    WitBindgenCfg(WitBindgenConfig),

    /// '<namespace>:<package>/<interface>' combinations that are allowed to be exposed over the lattice
    ///
    /// If no interfaces are specified, all are allowed.
    /// If one or more interfaces are specified, then only those interfaces will be exposed over the lattice.
    ///
    /// If combined with the deny list, this listing will be used first (creating the list of allowed fns).
    ExposedFnAllowList(WitFnList),

    /// '<namespace>:<package>/<interface>' combinations that are explicitly disallowed from being exposed over the lattice.
    ///
    /// If combined with the allow list, this listing will be used last (filtering the list of allowed fns).
    ExposedFnDenyList(WitFnList),

    /// Strategy (e.x. first argument, bundle arguments into struct) to use
    /// when serializing imported WIT interfaces to be sent across the lattice
    ImportFnLatticeTranslationStrategy(WitFunctionLatticeTranslationStrategy),

    /// Strategy (e.x. first argument, bundle arguments into struct) to use
    /// when serializing exported WIT interfaces to be sent across the lattice
    ExportFnLatticeTranslationStrategy(WitFunctionLatticeTranslationStrategy),

    /// Strategy (e.x. first argument, bundle arguments into struct) to use
    /// when serializing exported WIT interfaces to be sent across the lattice
    ReplaceWitifiedMaps(syn::LitBool),
}

impl Parse for ProviderBindgenConfigOption {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let l = input.lookahead1();
        if l.peek(keywords::contract) {
            input.parse::<keywords::contract>()?;
            input.parse::<Token![:]>()?;
            Ok(ProviderBindgenConfigOption::Contract(input.parse()?))
        } else if l.peek(keywords::impl_struct) {
            input.parse::<keywords::impl_struct>()?;
            input.parse::<Token![:]>()?;
            Ok(ProviderBindgenConfigOption::ImplStruct(input.parse()?))
        } else if l.peek(keywords::exposed_interface_allow_list) {
            input.parse::<keywords::exposed_interface_allow_list>()?;
            input.parse::<Token![:]>()?;
            Ok(ProviderBindgenConfigOption::ExposedFnAllowList(
                input.parse()?,
            ))
        } else if l.peek(keywords::exposed_interface_deny_list) {
            input.parse::<keywords::exposed_interface_deny_list>()?;
            input.parse::<Token![:]>()?;
            Ok(ProviderBindgenConfigOption::ExposedFnDenyList(
                input.parse()?,
            ))
        } else if l.peek(keywords::wit_bindgen_cfg) {
            input.parse::<keywords::wit_bindgen_cfg>()?;
            input.parse::<Token![:]>()?;
            Ok(ProviderBindgenConfigOption::WitBindgenCfg(input.parse()?))
        } else if l.peek(keywords::wit_namespace) {
            input.parse::<keywords::wit_namespace>()?;
            input.parse::<Token![:]>()?;
            Ok(ProviderBindgenConfigOption::WitNamespace(input.parse()?))
        } else if l.peek(keywords::wit_package) {
            input.parse::<keywords::wit_package>()?;
            input.parse::<Token![:]>()?;
            Ok(ProviderBindgenConfigOption::WitPackage(input.parse()?))
        } else if l.peek(keywords::import_fn_lattice_translation_strategy) {
            input.parse::<keywords::import_fn_lattice_translation_strategy>()?;
            input.parse::<Token![:]>()?;
            Ok(ProviderBindgenConfigOption::ImportFnLatticeTranslationStrategy(input.parse()?))
        } else if l.peek(keywords::export_fn_lattice_translation_strategy) {
            input.parse::<keywords::import_fn_lattice_translation_strategy>()?;
            input.parse::<Token![:]>()?;
            Ok(ProviderBindgenConfigOption::ExportFnLatticeTranslationStrategy(input.parse()?))
        } else if l.peek(keywords::replace_witified_maps) {
            input.parse::<keywords::replace_witified_maps>()?;
            input.parse::<Token![:]>()?;
            Ok(ProviderBindgenConfigOption::ReplaceWitifiedMaps(
                input.parse()?,
            ))
        } else {
            Err(syn::Error::new(
                Span::call_site(),
                "unrecognized keyword provided to wamscloud_provider_wit_bindgen",
            ))
        }
    }
}

/// The strategy used to expose a function and its arguments on the wasmCloud lattice
#[derive(Debug, Default, PartialEq, Eq, Clone)]
enum WitFunctionLatticeTranslationStrategy {
    /// Automatically determine how to bundle a function and its arguments to be sent over the lattice
    ///
    /// Generally, this means detecting whether the function has a single argument or multiple
    /// and choosing whether to send that single argument or bundle up all arguments into a generated Invocation struct.
    #[default]
    Auto,

    /// First argument usage assumes that every function that should be exported to the lattice
    /// has *one* argument, which is the object that should be serialized and set out onto the lattice.
    ///
    /// For example, the following WIT:
    ///
    /// ```ignore
    /// interface example {
    ///   f: func(input: string);
    ///
    ///   record g-request {
    ///     first: string;
    ///     second: u32;
    ///     third: bool;
    ///   }
    ///
    ///   g: func(input: g-request);
    ///
    ///   h: func(first: bool, second: string);
    /// }
    /// ```
    ///
    /// Under this setting, bindgen will produce an error on function `h`, as it contains multiple arguments
    FirstArgument,

    /// Argument bundling assumes that every function that should be exported to the lattice
    /// has *one or more* arguments, which are bundled into an object that should be serialized and set out onto the lattice.
    ///
    /// For example, the following WIT:
    ///
    /// ```ignore
    /// package examples:arg-bundle;
    ///
    /// interface example {
    ///   f: func(input: string);
    ///
    ///   record g-request {
    ///     first: string;
    ///     second: u32;
    ///     third: bool;
    ///   }
    ///
    ///   g: func(input: g-request);
    ///
    ///   h: func(first: bool, second: string);
    /// }
    /// ```
    ///
    /// Under this setting, bindgen will not produce an error on any function, but will be slightly
    /// inefficient as it will wrap `f` in a generated `ExamplesArgBundleFInvocation` struct (containing one member, `input`).
    BundleArguments,
}

impl WitFunctionLatticeTranslationStrategy {
    /// Translate a wit-bindgen generated trait function for use across the lattice
    fn translate_import_fn_for_lattice(
        &self,
        bindgen_cfg: &ProviderBindgenConfig,
        wit_iface_path: WitInterfacePath,
        trait_method: &TraitItemFn,
        struct_lookup: &StructLookup,
        type_lookup: &TypeLookup,
    ) -> anyhow::Result<(WitInterfacePath, LatticeMethod)> {
        let lattice_method_name = LitStr::new(
            format!(
                "{}.{}",
                wit_iface_path
                    .split('.')
                    .last()
                    .map(ToUpperCamelCase::to_upper_camel_case)
                    .with_context(|| format!(
                        "failed to retrieve WIT iface name from path [{}]",
                        wit_iface_path
                    ))?,
                trait_method.sig.ident.to_string().to_upper_camel_case()
            )
            .as_ref(),
            trait_method.sig.ident.span(),
        );

        match self {
            WitFunctionLatticeTranslationStrategy::Auto => match trait_method.sig.inputs.len() {
                0 | 1 => Self::translate_import_fn_via_first_arg(
                    wit_iface_path,
                    lattice_method_name,
                    trait_method,
                    struct_lookup,
                    type_lookup,
                ),
                _ => Self::translate_import_fn_via_bundled_args(
                    bindgen_cfg,
                    wit_iface_path,
                    lattice_method_name,
                    trait_method,
                    struct_lookup,
                    type_lookup,
                ),
            },
            WitFunctionLatticeTranslationStrategy::FirstArgument => {
                Self::translate_import_fn_via_first_arg(
                    wit_iface_path,
                    lattice_method_name,
                    trait_method,
                    struct_lookup,
                    type_lookup,
                )
            }
            WitFunctionLatticeTranslationStrategy::BundleArguments => {
                Self::translate_import_fn_via_bundled_args(
                    bindgen_cfg,
                    wit_iface_path,
                    lattice_method_name,
                    trait_method,
                    struct_lookup,
                    type_lookup,
                )
            }
        }
    }

    /// Translate a function for use on the lattice via the first argument.
    /// Functions that cannot be translated properly via this method will fail.
    fn translate_import_fn_via_first_arg(
        wit_iface_path: WitInterfacePath,
        lattice_method_name: LitStr,
        trait_method: &TraitItemFn,
        _struct_lookup: &StructLookup,
        _type_lookup: &TypeLookup,
    ) -> anyhow::Result<(WitInterfacePath, LatticeMethod)> {
        // It is possible to force first argument style handling, so double check
        ensure!(
            trait_method.sig.inputs.len() <= 1,
            "forcing translation of first arg for trait method [{}] that has more than one arg",
            trait_method.sig.ident,
        );

        // If there are no arguments, then we can add a lattice method with nothing:
        if trait_method.sig.inputs.is_empty() {
            return Ok((
                wit_iface_path.to_string().to_upper_camel_case(),
                LatticeMethod {
                    lattice_method_name,
                    type_name: None,
                    func_name: trait_method.sig.ident.clone(),
                    struct_members: None,
                    invocation_arg_names: Vec::new(),
                    invocation_return: trait_method.sig.output.clone(),
                },
            ));
        }

        // Get the first function argument, which will become the type sent across the lattice
        // Get the remaining tokens after the argument name and colon type name from the first argument
        let first_arg = trait_method.sig.inputs.iter().next().context(format!(
            "trait method [{}] has no arguments yet is attempting to translate via first arg",
            trait_method.sig.ident,
        ))?;

        // Process a function argument to retrieve the argument name and type name
        let (arg_name, type_name) = process_fn_arg(first_arg)?;

        Ok((
            wit_iface_path.to_string().to_upper_camel_case(),
            LatticeMethod {
                lattice_method_name,
                type_name: Some(type_name),
                func_name: trait_method.sig.ident.clone(),
                struct_members: None,
                invocation_arg_names: vec![arg_name],
                invocation_return: trait_method.sig.output.clone(),
            },
        ))
    }

    /// Translate a function for use on the lattice via bundled args.
    /// Functions that cannot be translated properly via this method will fail.
    fn translate_import_fn_via_bundled_args(
        bindgen_cfg: &ProviderBindgenConfig,
        wit_iface_name: WitInterfacePath,
        lattice_method_name: LitStr,
        trait_method: &TraitItemFn,
        struct_lookup: &StructLookup,
        type_lookup: &TypeLookup,
    ) -> anyhow::Result<(WitInterfacePath, LatticeMethod)> {
        // Create an identifier for the new struct that will represent the function invocation coming
        // across the lattice, in a <CamelCaseModule><CamelCaseInterface><CamelCaseFunctionName> pattern
        // (ex. MessagingConsumerRequestMultiInvocation)
        let struct_name = format_ident!(
            "{}{}Invocation",
            wit_iface_name.to_upper_camel_case(),
            trait_method.sig.ident.to_string().to_upper_camel_case()
        );

        // Build a list of invocation arguments similar to the structs
        let mut invocation_arg_names: Vec<Ident> = Vec::new();

        // Transform the members and remove any lifetimes by manually converting references to owned data
        // (i.e. doing things like converting a type like &str to String mechanically)
        let struct_members = trait_method
                .sig
                // Get all function inputs for the function signature
                .inputs
                .iter()
                .enumerate()
                .fold(TokenStream::new(), |mut tokens, (idx, arg)| {
                    // If we're not the first index, add a comma
                    if idx != 0 {
                        tokens.append_all([&TokenTree::Punct(Punct::new(',', proc_macro2::Spacing::Alone))]);
                    }

                    // Match on a single input argument in the function signature,
                    // converting known types to ones that can be used as invocation struct members.
                    match &arg
                            .to_token_stream()
                            .into_iter()
                            .collect::<Vec<TokenTree>>()[..]
                        {
                            // pattern: 'name: &T'
                            simple_ref @ &[
                                TokenTree::Ident(ref n), // name
                                TokenTree::Punct(_), // :
                                TokenTree::Punct(ref p), // &
                                TokenTree::Ident(ref t), // T
                            ] if p.as_char() == '&' => {
                                // Save the invocation argument for later
                                invocation_arg_names.push(n.clone());

                                // Match the type that came out of the simple case
                                match t.to_string().as_str() {
                                    // A &str
                                    "str" => {
                                        tokens.append_all([
                                            &simple_ref[0],
                                            &simple_ref[1],
                                            // replace the type with an owned string
                                            &TokenTree::Ident(Ident::new("String", t.span())),
                                        ]);
                                    },

                                    // Unexpected non-standard type as reference
                                    // (likely a known custom type generated by wit-bindgen)
                                    _ => {

                                        // Add a modified group of tokens to the list for the struct
                                        tokens.append_all([
                                            &simple_ref[0], // name
                                            &simple_ref[1], // colon
                                        ]);

                                        let arg_type = &simple_ref[3].to_string();

                                        // If we have a T that this module defined, we must use the full path to it
                                        // if not, it is likely a builtin, so we can use it directly
                                        if let Some((struct_path, _)) = struct_lookup.get(arg_type) { // struct
                                            tokens.append_all([ struct_path.to_token_stream() ]);
                                        } else if let Some((type_path, _)) = type_lookup.get(arg_type) { // type
                                            tokens.append_all([ type_path.to_token_stream() ]);
                                        } else {
                                            tokens.append_all([ &simple_ref[3]]);
                                        };
                                    }
                                }
                            },

                            // pattern: 'name: Wrapper<&T>'
                            wrapped_ref @ &[
                                TokenTree::Ident(ref n),  // name
                                TokenTree::Punct(_),  // :
                                TokenTree::Ident(_),  // Wrapper
                                TokenTree::Punct(ref p),  // <
                                TokenTree::Punct(ref p2), // &
                                ..,  // T
                                TokenTree::Punct(_) // >
                            ] if p.as_char() == '<' && p2.as_char() == '&' => {
                                // Save the invocation argument for later
                                invocation_arg_names.push(n.clone());

                                // Slice out the parts in between the < ... >
                                let type_section = &wrapped_ref[4..wrapped_ref.len()];

                                match type_section {
                                    // case: str (i.e. Vec<&str>)
                                    [
                                        TokenTree::Punct(_), // <
                                        TokenTree::Ident(ref n),
                                        TokenTree::Punct(_) // >
                                    ] if n.to_string().as_str() == "str" => {
                                        tokens.append_all([
                                            &wrapped_ref[0], // name
                                            &wrapped_ref[1], // colon
                                            &wrapped_ref[2], // wrapper
                                            &wrapped_ref[3], // <
                                            &TokenTree::Ident(Ident::new("String", n.span())),
                                            &wrapped_ref[5], // >
                                        ]);
                                    },

                                    // case: [u8] (i.e. Vec<&[u8]>)
                                    [
                                        TokenTree::Punct(_), // <
                                        TokenTree::Group(g),
                                        TokenTree::Punct(_), // >
                                    ] if g.to_string().as_str() == "[u8]" => {
                                        tokens.append_all([
                                            &wrapped_ref[0], // name
                                            &wrapped_ref[1], // colon
                                            &wrapped_ref[2], // wrapper
                                            &wrapped_ref[3], // <
                                            &TokenTree::Ident(Ident::new("Vec", Span::call_site())), // Vec
                                            &TokenTree::Punct(Punct::new('<', Spacing::Joint)), // <
                                            &TokenTree::Ident(Ident::new("u8", Span::call_site())), // u8
                                            &TokenTree::Punct(Punct::new('>', Spacing::Joint)), // >
                                            &TokenTree::Punct(Punct::new('>', Spacing::Joint)), // >
                                        ]);
                                    },

                                    // case: T (i.e. Vec<T>)
                                    rest =>  {
                                        let arg_type = &rest[1].to_string();

                                        // If we have a < T >, and T is a struct this module defined, we must use the full path to it
                                        // if not, it is likely a builtin, so we can use it directly
                                        if let Some((struct_path, _)) = struct_lookup.get(arg_type) {
                                            tokens.append_all(&wrapped_ref[0..5]);
                                            tokens.append_all([ struct_path.to_token_stream() ]);
                                            tokens.append_all(&wrapped_ref[6..]);
                                        } else if let Some((type_path, _)) = type_lookup.get(arg_type) {
                                            tokens.append_all(&wrapped_ref[0..5]);
                                            tokens.append_all([ type_path.to_token_stream() ]);
                                            tokens.append_all(&wrapped_ref[6..]);
                                        } else {
                                            tokens.append_all(wrapped_ref);
                                        };
                                    },
                                }
                            },

                            // case: Vec<(String, T)> (WIT-ified map)
                            // NOTE: this only works for arguments that end in '_map'
                            ts if bindgen_cfg.replace_witified_maps
                                && ts.len() > 2 // in order to skip the name & colon tokens
                                && matches!(ts[0], TokenTree::Ident(ref n) if n.to_string().ends_with("_map"))
                                && extract_witified_map(&ts[2..]).is_some() => {
                                    let arg_name = Ident::new(ts[0].to_string().trim_end_matches("_map"), ts[0].span());
                                    let map_type = extract_witified_map(&ts[2..]).expect("failed to parse WIT-ified map type");
                                    tokens.append_all(quote::quote!(#arg_name: #map_type));
                            },

                            // pattern: unknown (any T)
                            ts => {
                                // Save the first token (which should be the argument name) as an invocation argument for later
                                if let TokenTree::Ident(name) = &ts[0] {
                                    invocation_arg_names.push(name.clone());
                                }

                                // With a completely unknown type, we should attempt to replace it with a qualified type name
                                match &ts[2] {
                                    // If the third token (after the arg name and ':') has a type we know, fill in the qualified name
                                    TokenTree::Ident(name) if type_lookup.contains_key(&name.to_string()) => {
                                        let qualified_type = type_lookup.get(&name.to_string()).unwrap().0.to_token_stream();
                                        tokens.append_all(&ts[0..2]);
                                        tokens.append_all(qualified_type);
                                        tokens.append_all(&ts[3..]);
                                    }
                                    // Ignore types that aren't in some lookup
                                    _ => tokens.append_all(ts)
                                }
                            }
                        }

                    tokens
                });

        Ok((
            wit_iface_name.to_string().to_upper_camel_case(),
            LatticeMethod {
                lattice_method_name,
                type_name: Some(struct_name.to_token_stream()),
                struct_members: Some(struct_members),
                func_name: trait_method.sig.ident.clone(),
                invocation_arg_names,
                invocation_return: trait_method.sig.output.clone(),
            },
        ))
    }

    /// Translate an exported WIT function automatically by detecting the number of arguments
    fn translate_export_fn_for_lattice(
        &self,
        iface: &wit_parser::Interface,
        iface_fn_name: &String,
        iface_fn: &wit_parser::Function,
        cfg: &ProviderBindgenConfig,
    ) -> anyhow::Result<(Vec<StructTokenStream>, Vec<FunctionTokenStream>)> {
        match self {
            WitFunctionLatticeTranslationStrategy::Auto => {
                match &iface_fn.params.as_slice() {
                    // Handle the no-parameter case
                    [] => {
                        let lattice_method = LitStr::new(
                            format!(
                                "{}.{}",
                                iface
                                    .name
                                    .as_ref()
                                    .context("failed to find interface name")?
                                    .to_upper_camel_case(),
                                iface_fn_name.to_upper_camel_case()
                            )
                            .as_str(),
                            Span::call_site(),
                        );
                        let contract_ident = LitStr::new(&cfg.contract, Span::call_site());

                        let func_ts = quote::quote!(
                            async fn #iface_fn_name(
                                &self,
                            ) -> ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::error::InvocationError<()> {
                                let connection = ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::provider_main::get_connection();
                                let client = connection.get_rpc_client();
                                let response = client
                                    .send(
                                        ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::core::WasmCloudEntity {
                                            public_key: self.ld.provider_id.clone(),
                                            link_name: self.ld.link_name.clone(),
                                            contract_id: #contract_ident.to_string(),
                                        },
                                        ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::core::WasmCloudEntity {
                                            public_key: self.ld.actor_id.clone(),
                                            ..Default::default()
                                        },
                                        #lattice_method,
                                        ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::serialize(())?
                                    )
                                    .await?;

                                if let Some(err) = response.error {
                                    Err(::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::error::InvocationError::Unexpected(err.to_string()))
                                } else {
                                    Ok(())
                                }
                            }
                        );

                        Ok((vec![], vec![func_ts]))
                    }
                    // Handle the single parameter case
                    [(arg_name, arg_type)] => {
                        // If there is one input, we can use it assuming it is the message being sent out onto the lattice
                        Self::translate_export_fn_via_first_arg(
                            iface,
                            iface_fn_name,
                            arg_name,
                            arg_type,
                            &iface_fn.results,
                            cfg,
                        )
                    }
                    // For exported functions with >1 parameters, we must attempt bundling the arguments into one object
                    // to be sent out over the lattice
                    _ => Self::translate_export_fn_via_bundled_args(
                        iface,
                        iface_fn_name,
                        iface_fn,
                        cfg,
                    ),
                }
            }
            WitFunctionLatticeTranslationStrategy::FirstArgument => {
                if let [(arg_name, arg_type)] = &iface_fn.params.as_slice() {
                    Self::translate_export_fn_via_first_arg(
                        iface,
                        iface_fn_name,
                        arg_name,
                        arg_type,
                        &iface_fn.results,
                        cfg,
                    )
                } else {
                    bail!("function parameters for interface function {iface_fn_name} have more than one argument");
                }
            }
            WitFunctionLatticeTranslationStrategy::BundleArguments => {
                Self::translate_export_fn_via_bundled_args(iface, iface_fn_name, iface_fn, cfg)
            }
        }
    }

    /// Translate an exported WIT function via first argument
    fn translate_export_fn_via_first_arg(
        iface: &wit_parser::Interface,
        iface_fn_name: &str,
        arg_name: &str,
        arg_type: &wit_parser::Type,
        results: &wit_parser::Results,
        cfg: &ProviderBindgenConfig,
    ) -> anyhow::Result<(Vec<StructTokenStream>, Vec<FunctionTokenStream>)> {
        let rust_type = convert_wit_type(arg_type, cfg)?;
        let fn_name = Ident::new(iface_fn_name.to_snake_case().as_str(), Span::call_site());
        let lattice_method = LitStr::new(
            format!(
                "{}.{}",
                iface
                    .name
                    .as_ref()
                    .context("failed to find interface name")?
                    .to_upper_camel_case(),
                iface_fn_name.to_upper_camel_case()
            )
            .as_str(),
            Span::call_site(),
        );

        let arg_name_ident = Ident::new(arg_name, Span::call_site());

        let contract_ident = LitStr::new(&cfg.contract, Span::call_site());

        // Convert the WIT result type into a Rust type
        let result_rust_type = results.to_rust_type(cfg).with_context(|| {
            format!(
                "Failed to convert WIT function results (returns) while parsing interface [{}]",
                iface.name.clone().unwrap_or("<unknown>".into()),
            )
        })?;

        // If the rust_type we're expecting to deal with is unit (`()`), we must return the unit
        // instead of trying to deserialize what will eventually be an empty response (response.msg = [])
        // into bytes.
        //
        // Attempting to convert an empty byte slice with wasmcloud_provider_sdk::deserialize will fail
        // with an InvalidMarkerRead error, complaining about failing to fill the whole buffer.
        let deser_phrase = if is_rust_unit_type(&result_rust_type) {
            quote::quote!(Ok(()))
        } else {
            quote::quote!(Ok(
                ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::deserialize(
                    &response.msg
                )?
            ))
        };

        // Return the generated function with appropriate args & return
        let func_tokens = quote::quote!(
            async fn #fn_name(
                &self,
                #arg_name_ident: #rust_type
            ) -> ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::error::InvocationResult<#result_rust_type> {
                let connection = ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::provider_main::get_connection();
                let client = connection.get_rpc_client();
                let response = client
                    .send(
                        ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::core::WasmCloudEntity {
                            public_key: self.ld.provider_id.clone(),
                            link_name: self.ld.link_name.clone(),
                            contract_id: #contract_ident.to_string(),
                        },
                        ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::core::WasmCloudEntity {
                            public_key: self.ld.actor_id.clone(),
                            ..Default::default()
                        },
                        #lattice_method,
                        ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::serialize(&#arg_name_ident)?
                    )
                    .await?;

                if let Some(err) = response.error {
                    Err(::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::error::InvocationError::Unexpected(err.to_string()))
                } else {
                    #deser_phrase
                }
            }
        );

        Ok((vec![], vec![func_tokens]))
    }

    /// Translate an exported WIT function via bundled arguments
    fn translate_export_fn_via_bundled_args(
        iface: &wit_parser::Interface,
        iface_fn_name: &str,
        iface_fn: &wit_parser::Function,
        cfg: &ProviderBindgenConfig,
    ) -> anyhow::Result<(Vec<StructTokenStream>, Vec<FunctionTokenStream>)> {
        let fn_params = &iface_fn.params;
        let fn_results = &iface_fn.results;
        let contract_ident = LitStr::new(&cfg.contract, Span::call_site());
        let fn_name = Ident::new(iface_fn_name.to_snake_case().as_str(), Span::call_site());
        let lattice_method = LitStr::new(
            format!(
                "{}.{}",
                iface
                    .name
                    .as_ref()
                    .context("failed to find interface name")?
                    .to_upper_camel_case(),
                iface_fn_name.to_upper_camel_case()
            )
            .as_str(),
            Span::call_site(),
        );
        // Build the invocation struct that will be used
        let invocation_struct_name = format_ident!("{}Args", iface_fn_name.to_upper_camel_case());

        // Build an Args struct for the arguments to this interface function
        let mut struct_member_tokens: TokenStream = TokenStream::new();
        for (idx, (name, ty_id)) in fn_params.iter().enumerate() {
            let raw_type = convert_wit_type(ty_id, cfg)?;
            let name = format_ident!("{}", name);
            struct_member_tokens.append_all(quote::quote!(#name: #raw_type));
            if idx != fn_params.len() - 1 {
                struct_member_tokens.append(TokenTree::Punct(Punct::new(
                    ',',
                    proc_macro2::Spacing::Alone,
                )));
            }
        }

        // Build a struct that will be used to send args across the lattice
        //
        // This struct will eventually be written out, before the InvocationHandlers
        let invocation_struct_tokens = quote::quote!(
            #[derive(Debug, ::wasmcloud_provider_wit_bindgen::deps::serde::Serialize, ::wasmcloud_provider_wit_bindgen::deps::serde::Deserialize)]
            #[serde(crate = "::wasmcloud_provider_wit_bindgen::deps::serde")]
            pub struct #invocation_struct_name {
                #struct_member_tokens
            }
        );

        // Convert the WIT result type into a Rust type
        let result_rust_type = fn_results.to_rust_type(cfg).with_context(|| {
            format!(
                "Failed to convert WIT function results (returns) while parsing interface [{}]",
                iface.name.clone().unwrap_or("<unknown>".into()),
            )
        })?;

        // Build token stream for the invocation function that can be called
        //
        // This function will eventually be written into the impl of an InvocationHandler
        let func_tokens = quote::quote!(
            async fn #fn_name(
                &self,
                args: #invocation_struct_name,
            ) -> ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::error::InvocationResult<#result_rust_type> {
                let connection = ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::provider_main::get_connection();
                let client = connection.get_rpc_client();
                let response = client
                    .send(
                        ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::core::WasmCloudEntity {
                            public_key: self.ld.provider_id.clone(),
                            link_name: self.ld.link_name.clone(),
                            contract_id: #contract_ident.to_string(),
                        },
                        ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::core::WasmCloudEntity {
                            public_key: self.ld.actor_id.clone(),
                            ..Default::default()
                        },
                        #lattice_method,
                        ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::serialize(&args)?
                    )
                    .await?;

                if let Some(err) = response.error {
                    Err(::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::error::InvocationError::Failed(err.to_string()))
                } else {
                    Ok(::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::deserialize(&response.msg)?)
                }
            }
        );

        Ok((vec![invocation_struct_tokens], vec![func_tokens]))
    }
}

impl FromStr for WitFunctionLatticeTranslationStrategy {
    type Err = std::io::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "auto" => Ok(Self::Auto),
            "bundle-arguments" => Ok(Self::BundleArguments),
            "first-argument" => Ok(Self::FirstArgument),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::InvalidInput,
                "failed",
            )),
        }
    }
}

impl Parse for WitFunctionLatticeTranslationStrategy {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let key = input.parse::<LitStr>()?;
        Self::from_str(key.value().as_str())
            .map_err(|e| syn::Error::new::<std::io::Error>(Span::call_site(), e))
    }
}

impl Parse for ProviderBindgenConfig {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let call_site = Span::call_site();
        // Ensure the configuration starts with '{' as it should be an object
        if !input.peek(syn::token::Brace) {
            return Err(syn::Error::new::<String>(
                call_site,
                "bindgen configuration should start with a brace ('{')".into(),
            ));
        }

        // Expect and parse a braced set of bindgen configuration options
        let values;
        braced!(values in input);
        let entries =
            Punctuated::<ProviderBindgenConfigOption, Token![,]>::parse_terminated(&values)?;

        // Gather members of bindgen
        let mut contract: Option<WasmcloudContract> = None;
        let mut impl_struct: Option<ImplStructName> = None;
        let mut wit_ns: Option<WitNamespaceName> = None;
        let mut wit_pkg: Option<WitPackageName> = None;
        let mut wit_bindgen_cfg: Option<WitBindgenConfig> = None;
        let mut import_fn_lattice_translation_strategy: Option<
            WitFunctionLatticeTranslationStrategy,
        > = None;
        let mut export_fn_lattice_translation_strategy: Option<
            WitFunctionLatticeTranslationStrategy,
        > = None;
        let mut exposed_interface_allow_list: Option<WitFnList> = None;
        let mut exposed_interface_deny_list: Option<WitFnList> = None;
        let mut replace_witified_maps: bool = false;

        // For each successfully parsed configuration entry in the map, build the appropriate bindgen option
        for entry in entries.into_pairs() {
            match entry.into_value() {
                ProviderBindgenConfigOption::Contract(c) => {
                    contract = Some(c.value());
                }
                ProviderBindgenConfigOption::WitNamespace(ns) => {
                    wit_ns = Some(ns.value());
                }
                ProviderBindgenConfigOption::WitPackage(pkg) => {
                    wit_pkg = Some(pkg.value());
                }
                ProviderBindgenConfigOption::ExposedFnAllowList(list) => {
                    exposed_interface_allow_list = Some(list)
                }
                ProviderBindgenConfigOption::ExposedFnDenyList(list) => {
                    exposed_interface_deny_list = Some(list)
                }
                ProviderBindgenConfigOption::ImplStruct(s) => impl_struct = Some(s.to_string()),
                ProviderBindgenConfigOption::WitBindgenCfg(cfg) => {
                    wit_bindgen_cfg = Some(cfg);
                }
                ProviderBindgenConfigOption::ImportFnLatticeTranslationStrategy(strat) => {
                    import_fn_lattice_translation_strategy = Some(strat);
                }
                ProviderBindgenConfigOption::ExportFnLatticeTranslationStrategy(strat) => {
                    export_fn_lattice_translation_strategy = Some(strat);
                }
                ProviderBindgenConfigOption::ReplaceWitifiedMaps(opt) => {
                    replace_witified_maps = opt.value();
                }
            }
        }

        // Build the bindgen configuration from the parsed parts
        syn::Result::Ok(ProviderBindgenConfig {
            impl_struct: impl_struct.ok_or_else(|| {
                syn::Error::new(
                    call_site,
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidInput,
                        "missing/invalid 'impl_struct' bindgen option",
                    ),
                )
            })?,
            contract: contract.ok_or_else(|| {
                syn::Error::new(
                    call_site,
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidInput,
                        "missing/invalid 'contract' bindgen option",
                    ),
                )
            })?,
            wit_ns,
            wit_pkg,
            exposed_interface_allow_list: exposed_interface_allow_list.unwrap_or_default().into(),
            exposed_interface_deny_list: exposed_interface_deny_list.unwrap_or_default().into(),
            wit_bindgen_cfg: Some(wit_bindgen_cfg.ok_or_else(|| {
                syn::Error::new(
                    call_site,
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidInput,
                        "missing/invalid 'wit_bindgen_cfg' arguments",
                    ),
                )
            })?),
            import_fn_lattice_translation_strategy: import_fn_lattice_translation_strategy
                .unwrap_or_default(),
            export_fn_lattice_translation_strategy: export_fn_lattice_translation_strategy
                .unwrap_or_default(),
            replace_witified_maps,
        })
    }
}

/// This macro generates functionality necessary to use a WIT-enabled Rust providers (binaries that are managed by the host)
#[proc_macro]
pub fn generate(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .init();

    let cfg = parse_macro_input!(input as ProviderBindgenConfig);
    let contract_ident = LitStr::new(&cfg.contract, Span::call_site());

    // Parse the WIT for files (a second time, in addition to what has been done to generate)
    // and build up a list of exported iface invocation methods and structs related to them
    let mut exported_iface_invocation_methods: Vec<TokenStream> = Vec::new();
    let mut exported_iface_invocation_structs: Vec<TokenStream> = Vec::new();

    // Resolve the WIT bindgen configuration, which at this point should definitely be present
    let wit_bindgen_cfg = cfg
        .wit_bindgen_cfg
        .as_ref()
        .context("configuration to pass to WIT bindgen is missing")
        .expect("failed to parse WIT bindgen configuration");

    for (_, world) in wit_bindgen_cfg.resolve.worlds.iter() {
        for (world_item, _) in world.exports.iter() {
            if let wit_parser::WorldKey::Interface(iface_id) = world_item {
                let iface = &wit_bindgen_cfg.resolve.interfaces[*iface_id];

                // If the interface is in a namespace that we know can't be used coming in from the lattice
                // then we should ignore it and not generate invocation handlers for it
                if let Some(pkg) = iface
                    .package
                    .map(|p| &wit_bindgen_cfg.resolve.packages[p].name)
                {
                    if pkg.namespace == "wasmcloud" && pkg.name == "bus" {
                        continue;
                    }
                }

                for (iface_fn_name, iface_fn) in iface.functions.iter() {
                    // For each function in an exported interface,
                    // we'll need to generate a method on the eventual InvocationHandler
                    // that will be built later.
                    //
                    // We expect functions on exported interface to consist of *one* argument which is
                    // normally a struct (WIT record type) what represents the information to be sent out on the lattice, ex.:
                    //
                    //  ```
                    //  interface handler {
                    //       use types.{some-message}
                    //       handle-message: func(msg: some-message) -> result<_, string>
                    //   }
                    //  ```
                    let (invocation_struct_tokens, invocation_method_tokens) = cfg
                        .export_fn_lattice_translation_strategy
                        .translate_export_fn_for_lattice(iface, iface_fn_name, iface_fn, &cfg)
                        .expect("failed to translate export fn");

                    // Augment the list of invocation methods that have to be fulfilled
                    exported_iface_invocation_methods.extend(invocation_method_tokens.into_iter());
                    exported_iface_invocation_structs.extend(invocation_struct_tokens.into_iter());
                }
            }
        }
    }

    // Expand the wasmtime::component macro with the given arguments
    let bindgen_tokens: TokenStream =
        expand_wasmtime_component(wit_bindgen_cfg).unwrap_or_else(syn::Error::into_compile_error);

    // Parse the bindgen-generated tokens into an AST
    // that will be used in the output (combined with other wasmcloud-specific generated code)
    let mut bindgen_ast: syn::File =
        syn::parse2(bindgen_tokens).expect("failed to parse wit-bindgen generated code as file");

    // Visit the code that has been generated, to extract information we'll need to modify it
    let mut visitor = WitBindgenOutputVisitor::new(&cfg);
    visitor.visit_file_mut(&mut bindgen_ast);

    // Turn the function calls into object declarations for receiving from lattice
    let methods_by_iface = build_lattice_methods_by_wit_interface(
        &visitor.serde_extended_structs,
        &visitor.type_lookup,
        &visitor.import_trait_methods,
        &cfg,
    )
    .expect("failed to build lattice methods from WIT interfaces");

    // Create the implementation struct name as an Ident
    let impl_struct_name = Ident::new_raw(cfg.impl_struct.as_str(), Span::call_site());

    // Build a list of match arms for the interfaces
    let mut interface_dispatch_match_arms: Vec<TokenStream> = Vec::new();

    let mut iface_tokens = TokenStream::new();
    for (wit_iface_name, methods) in methods_by_iface.iter() {
        let wit_iface = Ident::new(wit_iface_name, Span::call_site());

        // Add generated code for new XInvocation structs

        // Filter out type names and struct members for structs that should be generated
        let (struct_type_names, struct_members) = methods.clone().into_iter().fold(
            (Vec::<TokenStream>::new(), Vec::<TokenStream>::new()),
            |mut acc, lm| {
                if let (Some(sm), Some(type_name)) = (lm.struct_members, lm.type_name) {
                    acc.0.push(type_name);
                    acc.1.push(sm);
                }
                acc
            },
        );

        // Add generated struct code for the current interface
        iface_tokens.append_all(quote::quote!(
            // START: *Invocation structs & trait for #wit_iface
            #(
                #[derive(Debug, ::wasmcloud_provider_wit_bindgen::deps::serde::Serialize, ::wasmcloud_provider_wit_bindgen::deps::serde::Deserialize)]
                #[serde(crate = "wasmcloud_provider_wit_bindgen::deps::serde")]
                struct #struct_type_names {
                    #struct_members
                }
            )*
        ));

        // Generate main trait for this interface (ex. `WasiKeyvalueReadWrite`) that facilitates invocations
        // and pipes through calls to provider impl

        // NOTE: struct_members is *either*
        // - the actual member from the GeneratedStruct variant
        // - the typename + type from the single first arg

        // Create a list of lattice method names that will trigger provider calls
        let lattice_method_names = methods
            .clone()
            .into_iter()
            .map(|lm| lm.lattice_method_name)
            .collect::<Vec<LitStr>>();
        // Function names that providers will implement for lattice methods (these functions will be called)
        let func_names = methods
            .clone()
            .into_iter()
            .map(|lm| lm.func_name)
            .collect::<Vec<Ident>>();
        // Get the invocation args with names, which is either:
        // - all struct members if present
        // - the arg name plus type name for a known type
        // - an empty list for zero args
        let invocation_args_with_types = methods
            .clone()
            .into_iter()
            .map(|lm| {
                match (lm.struct_members, &lm.invocation_arg_names[..]) {
                    // If more than one argument was present, we should be dealing with that as
                    // an invocation struct
                    (Some(members), _) => members,
                    // For no arguments, then we don't need to add any invocation args
                    (None, []) => {
                        TokenStream::new()
                    },
                    // If there's one argument then we should add the single argument
                    (None, [first]) => {
                        let type_name = lm.type_name;
                        quote::quote!(#first: #type_name)
                    },
                    // All other combinations are invalid (ex. forcing first-argument parsing when there are muiltiple args to the fn),
                    _ => panic!("unexpectedly found more than 1 invocation arg in function [{}] name, wit_function_lattice_translation-strategy should likely not be set to 'first-argument'", lm.func_name),
                }
            })
            .collect::<Vec<TokenStream>>();

        // Invocation returns of the functions that are called for each lattice method
        let invocation_returns = methods
            .clone()
            .into_iter()
            .map(|lm| lm.invocation_return)
            .collect::<Vec<ReturnType>>();

        // Create and append the trait for the iface along with
        // the functions that should be implemented by the provider
        iface_tokens.append_all(quote::quote!(
            #[::wasmcloud_provider_wit_bindgen::deps::async_trait::async_trait]
            pub trait #wit_iface {
                fn contract_id() -> &'static str {
                    #contract_ident
                }

                #(
                    async fn #func_names (
                        &self,
                        ctx: ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::Context,
                        #invocation_args_with_types
                    ) #invocation_returns;
                )*
            }
            // END: *Invocation structs & trait for #wit_iface
        ));

        // Build input parsing and argument expressions for every match clause
        let (input_parsing_statements, post_self_args) =
            methods
                .clone()
                .into_iter()
                .fold((Vec::new(), Vec::new()), |mut acc, lm| {
                    if let Some(type_name) = lm.type_name {
                        // type_name tells us the single type that is coming in over the lattice.
                        //
                        // This can either be:
                        //  - a wit-bindgen-generated type (ex. some record type)
                        //  - a struct we created (a "bundle" generated under [`WitFunctionLatticeTranslationStrategy::BundleArguments`])
                        //  - a pre-existing type (ex. `String`)
                        //
                        // We can use this to generate lines for
                        acc.0.push(quote::quote!(let input: #type_name = ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::deserialize(&body)?;));

                        let invocation_arg_names = lm.invocation_arg_names;
                        acc.1.push(if invocation_arg_names.len() == 1 {
                            // If there is only one invocation argument (and we know the type name)
                            // then it's the input we read over the wire
                            quote::quote!(ctx, input)
                        } else {
                            // If there is more than one arg name, we have a bundle of arguments that was sent over the wire
                            // we must pass the *fields* of that struct in
                            let mut tokens = TokenStream::new();
                            invocation_arg_names.iter().enumerate().fold(&mut tokens, |ts, (idx, i)| {
                                // Append input since if we have multiple arguments they'll be coming in as one envelope over the lattice
                                ts.append_all(quote::quote!(input.#i));
                                if idx != invocation_arg_names.len() - 1 {
                                    ts.append(TokenTree::Punct(Punct::new(',', proc_macro2::Spacing::Alone)));
                                }
                                ts
                            });
                            quote::quote!(ctx, #tokens)
                        });
                    } else {
                        // If a type name is *not* present, we're dealing with a function that takes *no* input.
                        //
                        // This means that there's no input to be parsed, and only ctx as a post-self argument
                        acc.0.push(TokenStream::new());
                        acc.1.push(Ident::new("ctx", Span::call_site()).to_token_stream());
                    }
                    acc
                });

        // After building individual invocation structs and traits for each interface
        // we must build & hold on to the usage of these inside the match for the MessageDispatch trait
        interface_dispatch_match_arms.push(quote::quote!(
            #(
                #lattice_method_names => {
                    #input_parsing_statements
                    let result = #wit_iface::#func_names(
                        self,
                        #post_self_args
                    )
                        .await;
                    Ok(::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::serialize(&result)?)
                }
            )*
        ));
    }

    // Build a list of types that should be included
    let types: Vec<TokenStream> = visitor
        .type_lookup
        .iter()
        .filter_map(|(_, (_, ty))| {
            // If the name of the type is identical to a bindgen-produced struct that will
            // be added later, this was likely a type alias -- we won't need it
            if visitor
                .serde_extended_structs
                .contains_key(&ty.ident.to_string())
            {
                None
            } else {
                Some(ty.to_token_stream())
            }
        })
        .collect();

    // Build a list of structs that should be included
    let structs: Vec<TokenStream> = visitor
        .serde_extended_structs
        .iter()
        .map(|(_, (_, s))| s.to_token_stream())
        .collect();

    // Build a list of enums that should be included
    let enums: Vec<TokenStream> = visitor
        .serde_extended_enums
        .iter()
        .map(|(_, (_, s))| s.to_token_stream())
        .collect();

    // Build the final chunk of code
    let tokens = quote::quote!(
        // START: per-interface codegen
        #iface_tokens
        // END: per-interface codegen

        // START: wit-bindgen generated types
        #(
            #types
        )*
        // END: wit-bindgen generated types

        // START: wit-bindgen generated structs
        #(
            #structs
        )*
        // END: wit-bindgen generated structs

        // START: wit-bindgen generated enums
        #(
            #enums
        )*
        // END: wit-bindgen generated enums

        /// MessageDispatch ensures that your provider can receive and
        /// process messages sent to it over the lattice
        ///
        /// This implementation is a stub and must be filled out by implementers
        ///
        /// It would be preferable to use <T: SomeTrait> here, but the fact that  'd like to use
        #[::wasmcloud_provider_wit_bindgen::deps::async_trait::async_trait]
        impl ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::MessageDispatch for #impl_struct_name {
            async fn dispatch<'a>(
                &'a self,
                ctx: ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::Context,
                method: String,
                body: std::borrow::Cow<'a, [u8]>,
            ) -> ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::error::InvocationResult<Vec<u8>> {
                match method.as_str() {
                    #(
                        #interface_dispatch_match_arms
                    )*
                    _ => Err(::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::error::InvocationError::Malformed(format!(
                        "Invalid method name {method}"
                    )).into())
                }
            }
        }

        // START: general provider

        /// This trait categorizes all wasmCloud lattice compatible providers.
        ///
        /// It is a mirror of ProviderHandler for the purposes of ensuring that
        /// at least the following members are is supported.
        #[::wasmcloud_provider_wit_bindgen::deps::async_trait::async_trait]
        trait WasmcloudCapabilityProvider {
            async fn put_link(&self, ld: &::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::core::LinkDefinition) -> bool;
            async fn delete_link(&self, actor_id: &str);
            async fn shutdown(&self);
        }

        /// ProviderHandler ensures that your provider handles the basic
        /// required functionality of all Providers on a wasmCloud lattice.
        ///
        /// This implementation is a stub and must be filled out by implementers
        #[::wasmcloud_provider_wit_bindgen::deps::async_trait::async_trait]
        impl ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::ProviderHandler for #impl_struct_name {
            async fn put_link(&self, ld: &::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::core::LinkDefinition) -> bool {
                WasmcloudCapabilityProvider::put_link(self, ld).await
            }

            async fn delete_link(&self, actor_id: &str) {
                WasmcloudCapabilityProvider::delete_link(self, actor_id).await
            }

            async fn shutdown(&self) {
                WasmcloudCapabilityProvider::shutdown(self).await
            }
        }

        /// Given the implementation of ProviderHandler and MessageDispatch,
        /// the implementation for your struct is a guaranteed
        impl ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::Provider for #impl_struct_name {}

        // Structs that are used at Invocation Handling time
        #( #exported_iface_invocation_structs )*

        /// This handler serves to be used for individual invocations of the actor
        /// as performed by the host runtime
        ///
        /// Interfaces exported by the provider can use this to send traffic across the lattice
        pub struct InvocationHandler<'a> {
            ld: &'a ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::core::LinkDefinition,
        }

        impl<'a> InvocationHandler<'a> {
            pub fn new(ld: &'a ::wasmcloud_provider_wit_bindgen::deps::wasmcloud_provider_sdk::core::LinkDefinition) -> Self {
                Self { ld }
            }

            #(
                #exported_iface_invocation_methods
            )*
        }

    );

    tokens.into()
}

/// A struct for visiting the output of wit-bindgen
/// focused around gathering all the important declarations we care about
#[derive(Default)]
struct WitBindgenOutputVisitor {
    /// Whether to replace WIT-ified maps (`list<tuple<T,T>>`) with a map type (i.e. `std::collections::HashMap`)
    replace_witified_maps: bool,

    /// WIT namespace
    wit_ns: Option<WitNamespaceName>,

    /// WIT package
    wit_pkg: Option<WitPackageName>,

    /// List of interfaces that if specified, will only be exposed on the lattice.
    /// If left empty, this indicates that all interfaces should be exposed
    exposed_interface_allow_list: Vec<LatticeExposedInterface>,

    /// List of interfaces that should explicitly not be exposed on the lattice
    exposed_interface_deny_list: Vec<LatticeExposedInterface>,

    /// Parents of the current module being traversed
    parents: Vec<Ident>,

    /// Top level module that does contains all WIT exports
    /// normally with internal modules starting from namespace
    /// ex. ('exports' -> <WIT namespace> -> <WIT pkg>)
    exports_ns_module: Option<ItemMod>,

    /// Structs that were modified and extended to derive Serialize/Deserialize
    serde_extended_structs: StructLookup,

    /// Enums that were modified and extended to derive Serialize/Deserialize
    serde_extended_enums: EnumLookup,

    /// Lookup of encountered types that were produced by bindgen, with their fully qualified names
    type_lookup: TypeLookup,

    /// Functions in traits that we'll have to stub eventually
    import_trait_methods: HashMap<WitInterfacePath, Vec<TraitItemFn>>,
}

impl WitBindgenOutputVisitor {
    /// Build a new visitor to traverse a wit-bindgen generated syntax tree
    fn new(cfg: &ProviderBindgenConfig) -> Self {
        Self {
            wit_ns: cfg.wit_ns.clone(),
            wit_pkg: cfg.wit_pkg.clone(),
            exposed_interface_allow_list: cfg.exposed_interface_allow_list.clone(),
            exposed_interface_deny_list: cfg.exposed_interface_deny_list.clone(),
            replace_witified_maps: cfg.replace_witified_maps,
            ..Default::default()
        }
    }

    /// Check the distance of the current module from crate/generated wit-bindgen content root
    fn current_module_level(&self) -> usize {
        self.parents.len()
    }

    /// Get the full path to the current module
    /// ex. (`<namespace>::<package>::some::wit::interface`)
    fn current_module_full_path(&self) -> FullModulePath {
        self.parents
            .iter()
            .map(|i| i.to_string())
            .collect::<Vec<String>>()
            .join(".")
    }

    /// Get the name of the current module (e.x. `interface`)
    fn current_module_name(&self) -> Option<String> {
        self.parents.last().map(ToString::to_string)
    }

    /// Check if a given string is the same as the top-level WIT namespace that was detected
    fn is_wit_ns(&self, s: impl AsRef<str>) -> bool {
        if let Some(v) = &self.wit_ns {
            v == s.as_ref()
        } else {
            false
        }
    }

    /// Check whether a the current node is directly under the wasm namespace
    /// Primarily used for detecting the package
    /// i.e. '<ns>/<package>'
    fn at_wit_ns_module_child(&self) -> bool {
        self.parents
            .last()
            .is_some_and(|ps| self.is_wit_ns(ps.to_string()))
    }

    /// Check whether the direct parent has a given name value
    fn at_child_of_module(&self, name: impl AsRef<str>) -> bool {
        self.parents.last().is_some_and(|v| v == name.as_ref())
    }

    /// Check whether we are currently at a module *below* the 'exports' known module name
    fn at_exported_module(&self) -> bool {
        self.parents.iter().any(|v| v == EXPORTS_MODULE_NAME)
    }

    /// Check whether the current path matches any known WASI built-ins (ex. wasi::io)
    ///
    /// WASI built-ins usually need to be ignored by bindgen
    fn is_wasi_builtin(&self) -> bool {
        for builtin in [("wasi", "io")] {
            match (
                self.parents.iter().position(|v| v == builtin.0),
                self.parents.iter().position(|v| v == builtin.1),
            ) {
                (Some(n), Some(n1)) if n1 == n + 1 => {
                    // If we see the path specified above consecutively, we know
                    // that we're in the path of a builtin
                    return true;
                }
                _ => {}
            }
        }
        false
    }

    /// Check whether the current path matches any known wasmcloud local-only built-ins (ex. wasmcloud::bus::host)
    ///
    /// Structs/Enums/etc in the hierarchy that match this cannot be sent across the lattice,
    /// thus generation should generally not be done for them
    fn is_wasmcloud_local_only_builtin(&self) -> bool {
        for builtin in [("wasmcloud", "bus", "host")] {
            match (
                self.parents.iter().position(|v| v == builtin.0),
                self.parents.iter().position(|v| v == builtin.1),
                self.parents.iter().position(|v| v == builtin.2),
            ) {
                (Some(n), Some(n1), Some(n2)) if n2 == n1 + 1 && n1 == n + 1 => {
                    // If we see the path specified above consecutively, we know
                    // that we're in the path of a builtin
                    return true;
                }
                _ => {}
            }
        }
        false
    }
}

impl VisitMut for WitBindgenOutputVisitor {
    fn visit_item_mod_mut(&mut self, node: &mut ItemMod) {
        debug!(
            "(bindgen module hierarchy): {}> {}",
            "=".repeat(self.current_module_level()),
            node.ident
        );

        // Detect the WIT namespace while traversing the bindgen output
        //
        // We expect the top level rust module (i.e. level zero of the module hierarchy)
        // in a package with imports to be the wit namespace.
        //
        // Packages with exports (which may *only* have exports) have 'exports' at level zero
        // then follow a similar pattern
        if self.wit_ns.is_none()
            && ((self.current_module_level() == 0 && node.ident != EXPORTS_MODULE_NAME)
                || (self.current_module_level() == 1 && self.at_exported_module()))
        {
            self.wit_ns = Some(node.ident.to_string());
        }

        // Detect the WIT package while traversing the bindgen output
        //
        // We expect the second level rust module (i.e. level 1 in a zero-indexed module hierarchy)
        // in a package with imports to be the wit package name.
        //
        // Packages with exports (which may *only* have exports) have 'exports' at level zero
        // then follow a similar pattern. For example, one would expect a module hierarchy like
        // `exports -> <wit namespace> -> <wit package>`
        if (
            self.current_module_level() == 1
            && self.at_wit_ns_module_child()
            && !self.at_exported_module())
            // Exports only case
            || (self.current_module_level() == 2 && self.at_exported_module())
        {
            self.wit_pkg = Some(node.ident.to_string());
        }

        // Recognize the 'exports' module which contains
        // all the exported interfaces
        //
        // ASSUMPTION: all exported modules are put into a level 0 'exports' module
        // which contains the top level namespace again
        if self.current_module_level() == 1 && self.at_child_of_module(EXPORTS_MODULE_NAME) {
            // this would be the ('exports' -> <ns>) node, note 'exports' itself.
            self.exports_ns_module = Some(node.clone());
        }

        // ASSUMPTION: level 2 modules contain externally visible *or* used interfaces
        // (i.e. ones that are exported)
        // 'use' calls will  cause an interface to show up, but only if the
        // thing that uses it is imported/exported

        // Recur/Traverse deeper into the detected modules where possible
        if let Some((_, ref mut items)) = &mut node.content {
            // Save the current module before we go spelunking
            self.parents.push(node.ident.clone());
            for item in items {
                self.visit_item_mut(item);
            }
            self.parents.pop();
        }
    }

    fn visit_item_mut(&mut self, node: &mut syn::Item) {
        match node {
            Item::Trait(t) => 'visit_trait: {
                // If the trait is under a WASI built-in (ex. wasi:io),
                // we don't want to include it for any kind of post processing
                if self.is_wasi_builtin() {
                    break 'visit_trait;
                }

                // Retrieve the interface name from the module hierarchy (immediate parent)
                let iface = if let Some(iface) = self.parents.last() {
                    iface
                } else {
                    panic!(
                        "unexpectedly missing parent while processing trait {}",
                        t.ident
                    )
                };

                let wit_ns = self
                    .parents
                    .get(self.parents.len() - 3)
                    .unwrap_or_else(|| {
                        panic!("unexpectedly missing ns level package (2 up from [{iface}] in generated bindgen code)")
                    })
                    .to_string();
                let wit_pkg = self
                    .parents
                    .get(self.parents.len() - 2)
                    .unwrap_or_else(|| {
                        panic!("unexpectedly missing ns level package (1 up from [{iface}] in generated bindgen code)")
                    })
                    .to_string();
                let full_iface_name = format!("{wit_ns}:{wit_pkg}/{iface}");

                // Build the (ns,pkg,interface) triples used to control lattice-exposed interfaces
                let iface_triple: &LatticeExposedInterface = &(wit_ns, wit_pkg, iface.to_string());

                // Use the allow and deny lists to determine which interfaces should be processed
                match (
                    self.exposed_interface_allow_list.as_slice(),
                    self.exposed_interface_deny_list.as_slice(),
                ) {
                    // If neither allow nor deny were specified, we are unconstrained
                    ([], []) => {
                        debug!("processing interface [{full_iface_name}], unconstrained (no allow/deny list)");
                    }
                    // If allow list is present (and deny missing), process only allow list
                    (allow, []) => {
                        if allow.contains(iface_triple) {
                            debug!(
                                "processing interface [{full_iface_name}], included in allow list"
                            );
                        } else {
                            warn!(
                                "skipping interface [{full_iface_name}], missing from allow list"
                            );
                            return;
                        }
                    }
                    // If deny list is present (and allow missing), process only deny list
                    ([], deny) => {
                        if deny.contains(iface_triple) {
                            warn!("skipping interface [{full_iface_name}], included in deny list");
                            return;
                        } else {
                            debug!("processing interface [{full_iface_name}], not included in deny list");
                        }
                    }
                    // If both allow and deny are present, process allow then deny
                    (allow, deny) => {
                        if allow.contains(iface_triple) && !deny.contains(iface_triple) {
                            debug!("processing interface [{full_iface_name}], included in allow and not in deny");
                        } else {
                            warn!("[warn] skipping interface [{full_iface_name}], not included in allow or missing from deny");
                            return;
                        }
                    }
                };

                // wit-bindgen generated code contains a 'Host' trait which contains generated methods for all imported interfaces.
                //
                // In general, generated trait methods should become RPC calls that come in from the lattice
                // which means the function calls & arguments must be converted to serializable objects to be received
                if t.ident == HOST_IMPORTS_TRAIT_NAME {
                    for ti in t.items.iter_mut() {
                        if let TraitItem::Fn(tim) = ti {
                            // Prune the &self argument
                            let mut trimmed = tim.clone();
                            trimmed.sig.inputs = <Punctuated<FnArg, Token![,]>>::from_iter(
                                trimmed.sig.inputs.into_iter().skip(1),
                            );

                            // Convert wasmtime:Result<T, wasmtime::Error> -> T
                            match &mut trimmed
                                .sig
                                .output
                                .to_token_stream()
                                .into_iter()
                                .collect::<Vec<TokenTree>>()[..]
                            {
                                [
                                    TokenTree::Punct(_), // -
                                    TokenTree::Punct(_), // >
                                    TokenTree::Ident(ref w), // wasmtime
                                    TokenTree::Punct(_), // :
                                    TokenTree::Punct(_), // :
                                    TokenTree::Ident(ref r), // Result
                                    TokenTree::Punct(_), // <
                                    inner @ ..,
                                    TokenTree::Punct(_), // >
                                ] if w == "wasmtime" && r == "Result" => {
                                    let mut inner_tokens = TokenStream::new();
                                    inner.iter_mut().fold(&mut inner_tokens, |acc, v| {
                                        acc.append(v.clone());
                                        acc
                                    });

                                    let result_tokens = quote::quote!(-> #inner_tokens);

                                    trimmed.sig.output = syn::parse2::<ReturnType>(result_tokens.clone())
                                        .expect("failed to purge wasmtime::Result from method return");
                                     },
                                    _ => {},
                                }

                            // Save methods in traits that we must stub later
                            let full_path = self.current_module_full_path();
                            trace!(
                                "adding import trait method for path [{full_path}], trimmed signature: [{}]",
                                trimmed.sig.to_token_stream().to_string(),
                            );
                            self.import_trait_methods
                                .entry(full_path)
                                .or_default()
                                .push(trimmed);
                        }
                    }
                }
            }

            // Process type declarations that appear in bindgen output
            //
            // Primarily, we pick up the definitions here so that we can use them for full qualification later
            Item::Type(t) => {
                // Determine the import path to this type
                let mut import_path = Punctuated::<syn::PathSegment, Token![::]>::new();
                for p in self.parents.iter() {
                    import_path.push(syn::PathSegment::from(p.clone()));
                }
                import_path.push(syn::PathSegment::from(t.ident.clone()));

                // For types generated due to dependencies in WIT (ex. wasm internals like wasi::io::stream, wasmcloud::bus::lattice)
                // we must replace their convoluted (`super::...` prefixes with `crate::`)
                let mut cloned_t = t.clone();
                let ItemType {
                    ty: ref mut item_ty,
                    ..
                } = cloned_t;
                // If the type that we're about to process has `super::`s attached, we need to translate those
                // to the actual types they *should* be, which are likely hanging off the crate or some other
                // dep like `wasmtime` (ex. `wasmtime::component::Resource`)
                if count_preceeding_supers(item_ty.as_ref()) > 0 {
                    if let Type::Path(ty_path) = item_ty.as_mut() {
                        // Create a cloned version fo the original path to use for modifications
                        let cloned_ty_path = ty_path.clone();
                        // Clear out the segments on the original type path
                        ty_path.path.segments.clear();

                        // Push in `crate`
                        ty_path
                            .path
                            .segments
                            .push_value(PathSegment::from(quote::format_ident!("crate")));
                        ty_path
                            .path
                            .segments
                            .push_punct(Token![::](Span::call_site()));

                        // Push in all non-"super" segments
                        cloned_ty_path
                            .path
                            .segments
                            .iter()
                            .filter(|s| s.ident != "super")
                            .for_each(|s| {
                                if !ty_path.path.segments.empty_or_trailing() {
                                    ty_path
                                        .path
                                        .segments
                                        .push_punct(Token![::](Span::call_site()));
                                }
                                ty_path.path.segments.push_value(s.clone());
                            });
                    }
                };

                // We should only add this type to the type lookup if it is *not* already a processed struct
                // or enum, as those will be output at the top level in the bind-gen'd code.
                //
                // Having both the type declaration and the top level struct/enum declaration would cause a conflict
                if !self.serde_extended_enums.contains_key(&t.ident.to_string())
                    && !self
                        .serde_extended_structs
                        .contains_key(&t.ident.to_string())
                // We exclude built-in wasi types here because they *should*
                // be implemented & brought in as enums/structs
                    && !self.is_wasi_builtin()
                {
                    // Add the type to the lookup so it can be used later for fully qualified names
                    self.type_lookup
                        .insert(t.ident.to_string(), (import_path, cloned_t));
                }
            }

            Item::Enum(e) => {
                // If this is a generated enum (from a WIT record), add serde Serialize/Deserialize
                //
                // NOTE: we MUST allow in built-in wasi enums, since they are used by higher level code
                //
                // exclude top level structs, since they indirectly include the exported module
                if self.current_module_level() != 0
                    // Ensure the enum has not already been processed
                    && !self.serde_extended_enums.contains_key(&e.ident.to_string())
                    // Ensure that the enum is not already aliased to something else
                    // enums that are aliases have types that are already defined elsewhere
                    && !self.type_lookup.contains_key(&e.ident.to_string())
                {
                    // Clear all pre-existing attributes (i.e. [component])
                    e.attrs.clear();

                    // Clear all pre-existing attributes from fields (mostly [component])
                    for v in &mut e.variants {
                        v.attrs.clear();

                        // Process all fields in every variant to perform standard replacements
                        for f in &mut v.fields {
                            // If the type of a particular field is a Vec<u8>,
                            // opt in to serde's specialized handling since this is what the
                            // implementation written in the host currently expects
                            if f.ty == syn::parse_str::<Type>("Vec<u8>").expect("failed to parse") {
                                f.attrs.push(parse_quote!(#[serde(with = "::wasmcloud_provider_wit_bindgen::deps::serde_bytes")]));
                            }

                            // If an enum contains a type that is a resource (i.e. a wasmtime::component::Resource),
                            // we can't actually send that across the lattice, we can only send a *reference* to it.
                            //
                            // For now, resources are converted to u32s (i.e. their `rep()` or pointer), and sent across the lattice that way.
                            match &f
                                .ty
                                .to_token_stream()
                                .into_iter()
                                .collect::<Vec<TokenTree>>()[..] {
                                    [
                                        TokenTree::Ident(w), // wasmtime
                                        TokenTree::Punct(_), // :
                                        TokenTree::Punct(_), // :
                                        TokenTree::Ident(w1), // component
                                        TokenTree::Punct(_), // :
                                        TokenTree::Punct(_), // :
                                        TokenTree::Ident(w2), // Resource
                                        TokenTree::Punct(b1), // <
                                        _inner @ ..,
                                        TokenTree::Punct(b2), // >
                                    ] if w == "wasmtime"
                                        && w1 == "component"
                                        && w2 == "Resource"
                                        && b1.to_string() == "<"
                                        && b2.to_string() == ">" => {
                                        f.ty = syn::parse_str::<Type>("u32").expect("failed to parse");
                                    }
                                    _ => {}
                                }

                            // If the struct field is a WIT-ified map, then we should replace
                            // it with a proper hash map type
                            if self.replace_witified_maps
                                && f.ident
                                    .as_ref()
                                    .is_some_and(|i| i.to_string().ends_with("_map"))
                            {
                                if let Some(map_type) = extract_witified_map(
                                    &f.ty
                                        .to_token_stream()
                                        .into_iter()
                                        .collect::<Vec<TokenTree>>(),
                                ) {
                                    f.ty = parse_quote!(#map_type);
                                    f.ident = f.ident.as_mut().map(|i| {
                                        Ident::new(i.to_string().trim_end_matches("_map"), i.span())
                                    });
                                }
                            }
                        }
                    }

                    // Add the attributes we want to be present to the enum
                    e.attrs.append(&mut vec![
                        parse_quote!(
                            #[derive(Debug, ::wasmcloud_provider_wit_bindgen::deps::serde::Serialize, ::wasmcloud_provider_wit_bindgen::deps::serde::Deserialize)]
                        ),
                        parse_quote!(
                            #[serde(crate = "::wasmcloud_provider_wit_bindgen::deps::serde")]
                        ),
                    ]);

                    // Save the enum by name to the tally of structs that have been extended
                    // this is used later to generate interfaces, when generating interfaces, as a import path lookup
                    // so that types can be resolved (i.e. T -> path::to::T)
                    let mut import_path = Punctuated::<syn::PathSegment, Token![::]>::new();
                    for p in self.parents.iter() {
                        import_path.push(syn::PathSegment::from(p.clone()));
                    }
                    import_path.push(syn::PathSegment::from(e.ident.clone()));

                    // Disallow the case where two identically named enums exist under different paths
                    if self.serde_extended_enums.contains_key(&e.ident.to_string()) {
                        panic!("found duplicate instances of enum [${}]", e.ident);
                    }

                    self.serde_extended_enums
                        .insert(e.ident.to_string(), (import_path, e.clone()));
                }
            }

            // Process struct declarations that appear in the bindgen output
            Item::Struct(s) => {
                // If this is a generated struct (from a WIT record), add serde Serialize/Deserialize
                // exclude top level structs, since they indirectly include the exported module
                if self.current_module_level() != 0
                    && !self
                        .serde_extended_structs
                        .contains_key(&s.ident.to_string())
                    // We must exclude structs that are wasmcloud builtins, since we know some of them to be
                    // impossible to pass over the lattice in a  easy manner
                    && !self.is_wasmcloud_local_only_builtin()
                    // Exclude structs that are named exactly the same as the module,
                    // since that's the struct that we'll be replacing with the InvocationHandler
                    //
                    // Normally that module-named struct contains wasmtime::component::Func
                    // which cannot be Serialized
                    && !self.current_module_name().is_some_and(|m| s.ident == m.to_upper_camel_case())
                {
                    // Clear all pre-existing attributes (i.e. [component])
                    s.attrs.clear();

                    // Clear all pre-existing attributes from fields (mostly [component])
                    for f in &mut s.fields {
                        f.attrs.clear();

                        // If the type of a particular field is a Vec<u8>,
                        // opt in to serde's specialized handling since this is what the
                        // implementation written in the host currently expects
                        if f.ty == syn::parse_str::<Type>("Vec<u8>").expect("failed to parse") {
                            f.attrs.push(parse_quote!(#[serde(with = "::wasmcloud_provider_wit_bindgen::deps::serde_bytes")]));
                        }

                        // If the struct field is a WIT-ified map, then we should replace
                        // it with a proper hash map type
                        if self.replace_witified_maps
                            && f.ident
                                .as_ref()
                                .is_some_and(|i| i.to_string().ends_with("_map"))
                        {
                            if let Some(map_type) = extract_witified_map(
                                &f.ty
                                    .to_token_stream()
                                    .into_iter()
                                    .collect::<Vec<TokenTree>>(),
                            ) {
                                f.ty = parse_quote!(#map_type);
                                f.ident = f.ident.as_mut().map(|i| {
                                    Ident::new(i.to_string().trim_end_matches("_map"), i.span())
                                });
                            }
                        }
                    }

                    // Add the attributes we want to be present
                    s.attrs.append(&mut vec![
                        parse_quote!(
                            #[derive(Debug, ::wasmcloud_provider_wit_bindgen::deps::serde::Serialize, ::wasmcloud_provider_wit_bindgen::deps::serde::Deserialize)]
                        ),
                        parse_quote!(
                            #[serde(crate = "::wasmcloud_provider_wit_bindgen::deps::serde", rename_all = "camelCase")]
                        ),
                    ]);

                    // Save the Struct by name to the tally of structs that have been extended
                    // this is used later to generate interfaces, when generating interfaces, as a import path lookup
                    // so that types can be resolved (i.e. T -> path::to::T)
                    let mut struct_import_path = Punctuated::<syn::PathSegment, Token![::]>::new();
                    for p in self.parents.iter() {
                        struct_import_path.push(syn::PathSegment::from(p.clone()));
                    }
                    struct_import_path.push(syn::PathSegment::from(s.ident.clone()));

                    // Disallow the case where two identically named structs exist under different paths
                    if self
                        .serde_extended_structs
                        .contains_key(&s.ident.to_string())
                    {
                        panic!("found duplicate instances of struct [${}]", s.ident);
                    }

                    self.serde_extended_structs
                        .insert(s.ident.to_string(), (struct_import_path, s.clone()));
                }
            }

            _ => visit_item_mut(self, node),
        }
    }
}

/// A converted trait method that will go out on the lattice
#[derive(Debug, Clone)]
struct LatticeMethod {
    /// Lattice methods that depend on pre-existing types that are serializable (i.e. [`serde::Serializable`] directly and can be sent out on the lattice as-is.
    ///
    /// These types may be produced by wit-bindgen produced types, but *do not* have to be generated by
    /// this macro.
    ///
    /// Often produced when [`WitFunctionLatticeTranslationStrategy::FirstArgument`] is configured.
    /// The name of the method that would be used on the lattice
    lattice_method_name: LitStr,

    /// The name of the type can be deserialized to perform the invocation
    ///
    /// When this is a bindgen-generated struct, `type_name` will be the name of the struct, and
    /// when the type is known/a standard type, `struct_members` will be empty and this `type_name` will be the
    /// known value (ex. `String`)
    type_name: Option<TokenStream>,

    /// Tokens that represent the struct member declarations for the current lattice method
    ///
    /// This is normally used when there are *multiple* arguments to a function but they are bundled together to be used
    /// across the lattice (i.e. [`WitFunctionLatticeTranslationStrategy::BundleArguments`])
    ///
    /// This is only present when the `type_name` corresponds to a struct that we must generate as part of this macro
    struct_members: Option<TokenStream>,

    /// Function name for the method that will be called after a lattice invocation is received
    func_name: Ident,

    /// Invocation arguments, only names without types
    invocation_arg_names: Vec<Ident>,

    /// Return type of the invocation
    invocation_return: ReturnType,
}

/// Build [`LatticeMethod`]s (including related information to facilitate invocations)
/// for the imports of a WIT interface
fn build_lattice_methods_by_wit_interface(
    struct_lookup: &StructLookup,
    type_lookup: &TypeLookup,
    map: &HashMap<WitInterfacePath, Vec<TraitItemFn>>,
    bindgen_cfg: &ProviderBindgenConfig,
) -> anyhow::Result<HashMap<WitInterfacePath, Vec<LatticeMethod>>> {
    let mut methods_by_name: HashMap<WitInterfacePath, Vec<LatticeMethod>> = HashMap::new();

    // For every trait item generated by an imported WIT interface we must generate the appropriate
    // structures that are expected from incoming messages on the lattice.
    for (wit_iface_name, funcs) in map.iter() {
        for trait_method in funcs.iter() {
            // Convert the trait method to code that can be used on the lattice
            let (name, lattice_method) = bindgen_cfg
                .import_fn_lattice_translation_strategy
                .translate_import_fn_for_lattice(
                    bindgen_cfg,
                    wit_iface_name.into(),
                    trait_method,
                    struct_lookup,
                    type_lookup,
                )?;

            // Add the struct and its members to a list that will be used in another quote
            // it cannot be added directly/composed to a TokenStream here to avoid import conflicts
            // in case bindgen-defined types are used.
            methods_by_name
                .entry(name)
                .or_default()
                .push(lattice_method);
        }
    }
    Ok(methods_by_name)
}

/// Convert a WIT type into a TokenStream that contains a Rust type
///
/// This function is co-recursive with `convert_wit_typedef`, since type defs
/// and types can be recursively intertwined
fn convert_wit_type(
    t: &wit_parser::Type,
    cfg: &ProviderBindgenConfig,
) -> anyhow::Result<TokenStream> {
    match t {
        wit_parser::Type::Bool => Ok(quote::quote!(bool)),
        wit_parser::Type::U8 => Ok(quote::quote!(u8)),
        wit_parser::Type::U16 => Ok(quote::quote!(u16)),
        wit_parser::Type::U32 => Ok(quote::quote!(u32)),
        wit_parser::Type::U64 => Ok(quote::quote!(u64)),
        wit_parser::Type::S8 => Ok(quote::quote!(s8)),
        wit_parser::Type::S16 => Ok(quote::quote!(s16)),
        wit_parser::Type::S32 => Ok(quote::quote!(s32)),
        wit_parser::Type::S64 => Ok(quote::quote!(s64)),
        wit_parser::Type::Float32 => Ok(quote::quote!(f32)),
        wit_parser::Type::Float64 => Ok(quote::quote!(f64)),
        wit_parser::Type::Char => Ok(quote::quote!(char)),
        wit_parser::Type::String => Ok(quote::quote!(String)),
        wit_parser::Type::Id(tydef) => {
            // Look up the type in the WIT resolver
            let type_def = &cfg
                .wit_bindgen_cfg
                .as_ref()
                .context("WIT bindgen config missing")?
                .resolve
                .types[*tydef];

            convert_wit_typedef(type_def, cfg)
        }
    }
}

/// Convert a [`wit_parser::TypeDef`] (which can be found inside a [`wit_parser::Type`])
/// into a [`TokenStream`] which corresponds to a Rust type
///
/// This function is co-recursive with `convert_wit_type`, since type defs
/// and types can be recursively intertwined
fn convert_wit_typedef(
    type_def: &wit_parser::TypeDef,
    cfg: &ProviderBindgenConfig,
) -> anyhow::Result<TokenStream> {
    // For nested types, the type_def.name is None and the kind goes deeper
    match &type_def.kind {
        // Nested type case (Option<...>)
        TypeDefKind::Option(ty_id) => {
            let ty = convert_wit_type(ty_id, cfg)?;
            Ok(quote::quote!(Option<#ty>))
        }
        // Nested type case (Result<...>)
        TypeDefKind::Result(Result_ { ok, err }) => {
            let ok_ty = if let Some(ty_id) = ok {
                convert_wit_type(ty_id, cfg)?
            } else {
                quote::quote!(())
            };
            let err_ty = if let Some(ty_id) = err {
                convert_wit_type(ty_id, cfg)?
            } else {
                quote::quote!(())
            };
            Ok(quote::quote!(Result<#ok_ty, #err_ty>))
        }
        // Nested type case (List<...>)
        TypeDefKind::List(ty_id) => {
            let ty = convert_wit_type(ty_id, cfg)?;
            Ok(quote::quote!(Vec<#ty>))
        }
        // Nested type case (owned data)
        TypeDefKind::Handle(Handle::Own(ty_idx)) => {
            let ty_def = cfg
                .wit_bindgen_cfg
                .as_ref()
                .context("missing WIT bindgen cfg resolver")?
                .resolve
                .types
                .get(*ty_idx)
                .context("failed to find type with given ID in WIT resolver")?;
            convert_wit_typedef(ty_def, cfg)
        }
        // Nested type case (borrowed data)
        TypeDefKind::Handle(Handle::Borrow(ty_idx)) => {
            let ty_def = cfg
                .wit_bindgen_cfg
                .as_ref()
                .context("missing WIT bindgen cfg resolver")?
                .resolve
                .types
                .get(*ty_idx)
                .context("failed to find type with given ID in WIT resolver")?;
            convert_wit_typedef(ty_def, cfg)
        }
        // Nested type case (Tuple)
        TypeDefKind::Tuple(Tuple { types }) => {
            let mut tuple_types = TokenStream::new();
            for (idx, tokens) in types
                .iter()
                .map(|t| convert_wit_type(t, cfg))
                .collect::<anyhow::Result<Vec<TokenStream>>>()
                .context("failed to parse all types in Tuple w/ types {types:?}")?
                .iter()
                .enumerate()
            {
                tuple_types.append_all(quote::quote!(#tokens));
                if idx != types.len() - 1 {
                    tuple_types.append(TokenTree::Punct(Punct::new(
                        ',',
                        proc_macro2::Spacing::Alone,
                    )));
                }
            }
            Ok(
                proc_macro2::Group::new(proc_macro2::Delimiter::Parenthesis, tuple_types)
                    .to_token_stream(),
            )
        }
        TypeDefKind::Stream(Stream { element, .. }) => {
            let element_ty = convert_wit_type(&element.context("missing type for stream")?, cfg)?;
            Ok(quote::quote!(impl Stream<Item=#element_ty>))
        }
        // Nested types that come through can run through
        // there's a potential for a cycle here, but it's unlikely
        TypeDefKind::Type(t) => convert_wit_type(t, cfg),
        // In the straight-forward cases below, we must just use the
        // name of the type and hope for the best:
        //
        // Since we get the wit type name here (in kebab case)
        // we'll expect the custom oxidized type to be upper camel case
        // (e.x. `chunk` -> `Chunk`)
        TypeDefKind::Variant(_) | TypeDefKind::Resource | TypeDefKind::Unknown => type_def
            .name
            .as_ref()
            .map(|v| v.to_upper_camel_case())
            .map(|v| Ident::new(&v, Span::call_site()).to_token_stream())
            .with_context(|| format!("failed to parse wit type def for type_def: {type_def:?}")),

        // For records that we encounter, they will be translated to Rust Structs by bindgen
        // we can pretend the struct exists because by the time the macro is done, it will.
        TypeDefKind::Record(_) => {
            let struct_name = format_ident!(
                "{}",
                type_def
                    .name
                    .as_ref()
                    .context("unexpectedly missing name for typedef")?
                    .to_upper_camel_case()
            );
            Ok(struct_name.to_token_stream())
        }

        _ => bail!("unsupported type kind {type_def:#?}"),
    }
}

/// Attempt to extract key and value types from a tree of tokens that is a witified map
///
/// For example, the following Rust type submitted as a list of tokens would be parsed successfully:
///
/// ```rust,ignore
/// Vec<(String, String)>
/// ```
fn extract_witified_map(input: &[TokenTree]) -> Option<TokenStream> {
    match input {
        // Handle WIT-ified maps that are wrapped in Option or Vec
        // i.e. Option<Vec<(K, V)>> or Vec<Vec<(K, V)>>
        [
            container @ TokenTree::Ident(container_ident), // Option
            TokenTree::Punct(p1), // <
            inner @ .. ,
            TokenTree::Punct(p2), // >
        ] if p1.as_char() == '<'
            && p2.as_char() == '>'
            && (*container_ident == "Option" || *container_ident == "Vec")
            // We need to know that the inner type is *not* a group
            // since this branch is only meant to a list of tuples (Vec<Vec<(....)>>)
            //
            // If the inner tokens are a group then we should head to the final case branch instead
            && inner.get(0).is_some_and(|tokens| !matches!(tokens, TokenTree::Group { .. })) => {
            let container_ts = container.to_token_stream();
            // Recursive call to extract the witified map from the inner type, re-wrapping in the container
            extract_witified_map(inner)
                .map(|t| parse_quote!(#container_ts<#t>))
        },

        // Handle WIT-ified maps that are unwrapped (i.e. a Vec<(K, V)>)
        [
            TokenTree::Ident(vec_ty),
            TokenTree::Punct(p1), // <
            TokenTree::Group(g),
            TokenTree::Punct(p2), // >
        ] if *vec_ty == "Vec" && p1.to_string() == "<" && p2.to_string() == ">" => {
            // The delimeter to the internal group must be delimited by parenthesis (it's a tuple)
            if g.delimiter() != proc_macro2::Delimiter::Parenthesis {
                return None;
            }

            // Now that we have the internal group (Vec< ...this bit... >),
            // we can extract the key and value type for the vec as a tuple
            let tokens = g.stream().into_iter().collect::<Vec<TokenTree>>();

            // Find the index of the comma which splits the types
            let comma_idx = tokens.iter().position(|t| matches!(t, TokenTree::Punct(p) if p.to_string() == ","))?;

            let key_type = TokenStream::from_iter(tokens[0..comma_idx].to_owned());
            let value_type = TokenStream::from_iter(tokens[comma_idx + 1..].to_owned());
            let map_type = parse_quote!(::std::collections::HashMap<#key_type,#value_type>);
            Some(map_type)
        },

        // All other matches cannot be WIT-ified maps
        _ => None,
    }
}

/// Process a first argument to retreive the argument name and type name used
fn process_fn_arg(arg: &FnArg) -> anyhow::Result<(Ident, TokenStream)> {
    // Retrieve the type pattern ascription (i.e. 'arg: Type') out of the first arg
    let pat_type = if let syn::FnArg::Typed(pt) = arg {
        pt
    } else {
        bail!("failed to parse pat type out of ");
    };

    // Retrieve argument name
    let mut arg_name = if let syn::Pat::Ident(n) = pat_type.pat.as_ref() {
        n.ident.clone()
    } else {
        bail!("unexpectedly non-ident pattern in {pat_type:#?}");
    };

    // If the argument name ends in _map, and the type matches a witified map (i.e. list<tuple<T, T>>)
    // then convert the type into a map *before* using it
    let type_name = match (
        arg_name.to_string().ends_with("_map"),
        extract_witified_map(
            &pat_type
                .ty
                .as_ref()
                .to_token_stream()
                .into_iter()
                .collect::<Vec<TokenTree>>(),
        ),
    ) {
        (true, Some(map_type)) => {
            arg_name = Ident::new(
                arg_name.to_string().trim_end_matches("_map"),
                arg_name.span(),
            );
            quote::quote!(#map_type)
        }
        _ => pat_type.ty.as_ref().to_token_stream(),
    };

    Ok((arg_name, type_name))
}

/// A trait that represents things that can be converted to a Rust type
trait ToRustType {
    /// Convert to a Rust type
    fn to_rust_type(&self, cfg: &ProviderBindgenConfig) -> anyhow::Result<TokenStream>;
}

impl ToRustType for wit_parser::Results {
    fn to_rust_type(&self, cfg: &ProviderBindgenConfig) -> anyhow::Result<TokenStream> {
        match self {
            // Convert a named return (usually simple, either empty or tuple)
            wit_parser::Results::Named(params) => {
                match params[..] {
                    // No results
                    // i.e. `func(arg: string)`
                    [] => Ok(quote::quote!(())),
                    // One or more results:
                    //
                    // e.x. `func(arg: string) -> string`
                    // e.x. `func(arg: string) -> ( string, string )`
                    ref params => {
                        let mut types: Vec<Ident> = Vec::new();
                        for (_, ty) in params.iter() {
                            types.push(syn::parse2::<Ident>(
                                convert_wit_type(ty, cfg).with_context(|| {
                                    format!("failed to convert WIT type [{ty:?}] to rust type]")
                                })?,
                            )?);
                        }
                        Ok(quote::quote!(( #( #types )* )))
                    }
                }
            }
            // Convert a return with arbitrary complexity
            wit_parser::Results::Anon(t) => {
                convert_wit_type(t, cfg).context("failed to find anonymous WIT type")
            }
        }
    }
}

/// Count the number of preceeding "super" calls a given [`syn::Type`] has,
/// if it is a [`syn::Type::Path`]
fn count_preceeding_supers(t: &Type) -> usize {
    if let Type::Path(t) = t {
        t.path
            .segments
            .iter()
            .filter(|s| s.ident == "super")
            .count()
    } else {
        0
    }
}

/// Check if a given TokenStream is the Rust unit type
fn is_rust_unit_type(t: &TokenStream) -> bool {
    t.to_string() == "()"
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use anyhow::{Context, Result};
    use proc_macro2::TokenTree;
    use syn::{parse_quote, LitStr, TraitItemFn};

    use crate::{
        extract_witified_map, ProviderBindgenConfig, WitFunctionLatticeTranslationStrategy,
    };

    /// Token trees that we expect to parse into WIT-ified maps should parse
    #[test]
    fn parse_witified_map_type() -> Result<()> {
        extract_witified_map(
            &quote::quote!(Vec<(String, String)>)
                .into_iter()
                .collect::<Vec<TokenTree>>(),
        )
        .context("failed to parse WIT-ified map type Vec<(String, String)>")?;
        Ok(())
    }

    /// Ensure WIT-ified maps parse correctly in functions
    #[test]
    fn parse_witified_map_in_fn() -> Result<()> {
        let trait_fn: TraitItemFn = parse_quote!(
            fn baz(test_map: Vec<(String, String)>) {}
        );
        let bindgen_cfg = ProviderBindgenConfig {
            impl_struct: "None".into(),
            contract: "wasmcloud:test".into(),
            wit_ns: Some("test".into()),
            wit_pkg: Some("foo".into()),
            exposed_interface_allow_list: Default::default(),
            exposed_interface_deny_list: Default::default(),
            wit_bindgen_cfg: None, // We won't actually run bindgen
            import_fn_lattice_translation_strategy: Default::default(),
            export_fn_lattice_translation_strategy: Default::default(),
            replace_witified_maps: true,
        };
        let (wit_iface_name, lm) =
            WitFunctionLatticeTranslationStrategy::translate_import_fn_via_bundled_args(
                &bindgen_cfg,
                "TestFoo".into(),
                LitStr::new("Foo", proc_macro2::Span::call_site()),
                &trait_fn,
                &HashMap::new(), // structs
                &HashMap::new(), // types
            )?;

        assert_eq!(wit_iface_name, "TestFoo");
        let type_name = lm.type_name.as_ref().context("failed to get type name")?;
        assert_eq!(type_name.to_string(), "TestFooBazInvocation");
        let struct_members = lm.struct_members.context("struct members missing")?;
        assert!(
            matches!(
                &struct_members.into_iter().collect::<Vec<TokenTree>>()[2..], // skip arg name & colon
                [
                    TokenTree::Punct(_),  // ":"
                    TokenTree::Punct(_),  // ":"
                    TokenTree::Ident(i1), // 'std'
                    TokenTree::Punct(_),  // ":"
                    TokenTree::Punct(_),  // ":"
                    TokenTree::Ident(i2), // 'collections'
                    TokenTree::Punct(_),  // ":"
                    TokenTree::Punct(_),  // ":"
                    TokenTree::Ident(i3), // 'HashMap'
                    TokenTree::Punct(b1), // "<"
                    TokenTree::Ident(key_type), // key type
                    TokenTree::Punct(c),  // ","
                    TokenTree::Ident(value_type), // value type
                    TokenTree::Punct(b2), // ">"
                ] if *i1 == "std" &&
                    *i2 == "collections" &&
                    *i3 == "HashMap" &&
                    b1.to_string() == "<" &&
                    c.to_string() == "," &&
                    *key_type == "String" &&
                    *value_type == "String" &&
                    b2.to_string() == ">"
            ),
            "struct members converted type is incorrect",
        );

        Ok(())
    }
}
