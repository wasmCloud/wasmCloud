mod common;

use common::TestWashInstance;

use anyhow::{bail, Context, Result};
use serial_test::serial;
use tokio::process::Command;
use wash_lib::cli::output::{
    GetClaimsCommandOutput, GetHostInventoriesCommandOutput, GetHostsCommandOutput,
    LinkQueryCommandOutput,
};

#[tokio::test]
#[serial]
async fn integration_get_hosts_serial() -> Result<()> {
    let wash_instance = TestWashInstance::create().await?;

    let output = Command::new(env!("CARGO_BIN_EXE_wash"))
        .args([
            "get",
            "hosts",
            "--output",
            "json",
            "--ctl-port",
            &wash_instance.nats_port.to_string(),
        ])
        .kill_on_drop(true)
        .output()
        .await
        .context("failed to execute get hosts")?;

    assert!(output.status.success(), "executed get hosts query");

    let cmd_output: GetHostsCommandOutput = serde_json::from_slice(&output.stdout)?;
    assert!(cmd_output.success, "command returned success");
    assert_eq!(cmd_output.hosts.len(), 1, "hosts contains one host");
    assert_eq!(
        cmd_output.hosts[0].id, wash_instance.host_id,
        "single host ID matches has the wash ID"
    );

    Ok(())
}

#[tokio::test]
#[serial]
async fn integration_get_links_serial() -> Result<()> {
    let wash_instance = TestWashInstance::create().await?;

    let output = Command::new(env!("CARGO_BIN_EXE_wash"))
        .args([
            "get",
            "links",
            "--output",
            "json",
            "--ctl-port",
            &wash_instance.nats_port.to_string(),
        ])
        .kill_on_drop(true)
        .output()
        .await
        .context("failed to execute get links")?;

    assert!(output.status.success(), "executed get links query");

    let cmd_output: LinkQueryCommandOutput = serde_json::from_slice(&output.stdout)?;
    assert!(cmd_output.success, "command returned success");
    assert_eq!(cmd_output.links.len(), 0, "links list is empty");

    Ok(())
}

#[tokio::test]
#[serial]
async fn integration_get_host_inventory_serial() -> Result<()> {
    let wash_instance = TestWashInstance::create().await?;

    let output = Command::new(env!("CARGO_BIN_EXE_wash"))
        .args([
            "get",
            "inventory",
            &wash_instance.host_id,
            "--output",
            "json",
            "--ctl-port",
            &wash_instance.nats_port.to_string(),
        ])
        .kill_on_drop(true)
        .output()
        .await
        .context("failed to execute get inventory")?;

    if !output.status.success() {
        bail!(
            "failed to execute `wash get inventory`, stdout: {} \nstderr: {}",
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr),
        );
    }

    let cmd_output: GetHostInventoriesCommandOutput = serde_json::from_slice(&output.stdout)?;
    assert!(cmd_output.success, "command returned success");

    assert!(
        cmd_output.inventories.len() == 1,
        "one host inventory returned"
    );
    let inventory = &cmd_output.inventories[0];
    assert!(
        inventory.actors.is_empty(),
        "host inventory contains no actors "
    );
    assert_eq!(
        inventory.host_id, wash_instance.host_id,
        "host ID matches request"
    );
    assert!(
        !inventory.labels.is_empty(),
        "at least one label on the host"
    );
    assert!(
        inventory.labels.contains_key("hostcore.os"),
        "hostcore.os label is present"
    );
    assert!(
        inventory.labels.contains_key("hostcore.arch"),
        "hostcore.arch label is present"
    );
    assert!(
        inventory.labels.contains_key("hostcore.osfamily"),
        "hostcore.osfmaily label is present"
    );
    assert!(inventory.providers.is_empty(), "host has no providers");

    Ok(())
}

#[tokio::test]
#[serial]
// TODO: reenable after #1649 merges and v1.0.0-alpha.2 is released
// This issue was fixed in 08bb43a8ae90dc83db653ed78b039479ffe1dd2e
#[ignore]
async fn integration_get_claims_serial() -> Result<()> {
    let wash_instance = TestWashInstance::create().await?;

    let output = Command::new(env!("CARGO_BIN_EXE_wash"))
        .args([
            "get",
            "claims",
            "--output",
            "json",
            "--ctl-port",
            &wash_instance.nats_port.to_string(),
        ])
        .kill_on_drop(true)
        .output()
        .await
        .context("failed to execute get claims")?;

    assert!(output.status.success(), "executed get claims query");

    let cmd_output: GetClaimsCommandOutput = serde_json::from_slice(&output.stdout)?;
    assert!(cmd_output.success, "command returned success");

    Ok(())
}
