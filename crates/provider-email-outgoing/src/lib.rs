//! Outgoing email capability provider built for [wasmCloud][wasmcloud]

use std::sync::OnceLock;

use dashmap::DashMap;
use lettre::message::header::ContentType;
use lettre::message::Mailbox;
use lettre::transport::smtp::authentication::Credentials as SmtpCredentials;
use lettre::transport::smtp::AsyncSmtpTransport;
use lettre::{AsyncTransport, Tokio1Executor};
use tracing::{debug, error, warn};

use wasmcloud_provider_sdk::{get_connection, run_provider, Context, LinkConfig, Provider};
use wit_bindgen_wrpc::anyhow::{Context as _, Result};

wit_bindgen_wrpc::generate!();

mod config;
use config::{ConfigName, OutgoingEmailConfig};

use crate::exports::wasmcloud::email::outgoing_config;
use crate::exports::wasmcloud::email::outgoing_sender;

static EMAIL_CONFIGS: OnceLock<DashMap<ConfigName, OutgoingEmailConfig>> = OnceLock::new();
#[allow(clippy::redundant_closure)]
fn get_email_configs() -> &'static DashMap<ConfigName, OutgoingEmailConfig> {
    EMAIL_CONFIGS.get_or_init(|| DashMap::new())
}

/// wasmCloud provider that handles outgoing email, which implements the `outgoing-email-provider` world
#[derive(Debug, Clone)]
pub struct OutgoingEmailProvider;

impl OutgoingEmailProvider {
    /// Execute the provider, loading default configuration from the host and subscribing
    /// on the proper RPC topics via `serve`, which is generated by wrpc bindgen
    pub async fn run() -> Result<()> {
        let provider = Self{};
        // TODO: Cloning here doesn't work well (obviously) for shared data --
        // we should be using an Arc<T> or something else so we can refer to the *same*
        // provider instance, rather than using the OnceLock<T> @ static level.
        //
        // Looks like Provider impls also need to be set to on the Arc<T>?
        let shutdown = run_provider(provider.clone(), "nats-messaging-provider")
            .await
            .context("failed to run provider")?;
        let connection = get_connection();
        serve(
            &connection.get_wrpc_client(connection.provider_key()),
            provider,
            shutdown,
        )
        .await
    }
}

/// Implementation of wasmCloud capability provider basics
impl Provider for OutgoingEmailProvider {
    async fn receive_link_config_as_target(
        &self,
        LinkConfig { config, .. }: LinkConfig<'_>,
    ) -> Result<()> {
        let configs = get_email_configs();
        // Build configuration from configuration by detecting OUTGOING_CFG_<x>_JSON
        for (key, value) in config {
            match key.to_lowercase() {
                // Parse out JSON for an outgoing config
                s if s.starts_with("outgoing_cfg_")
                    && s.ends_with("_json")
                    && s.split('_').collect::<Vec<_>>().len() == 4 =>
                {
                    match serde_json::from_str::<OutgoingEmailConfig>(value) {
                        Ok(cfg) => {
                            let name = s.split('_').collect::<Vec<&str>>()[2];
                            debug!(?name, "successfully parsed email config");
                            configs.insert(name.to_string(), cfg);
                        }
                        Err(e) => {
                            error!(error = ?e, key, "failed to parse outgoing email config from key");
                        }
                    }
                }
                // All other configuration is ignored
                _ => debug!("witnessed config key [{key}]"),
            }
        }
        Ok(())
    }

    async fn shutdown(&self) -> Result<()> {
        get_email_configs().clear();
        Ok(())
    }
}

/// Implement the required interfaces for outgoing config management
impl outgoing_config::Handler<Option<Context>> for OutgoingEmailProvider {
    async fn get_configuration(
        &self,
        _ctx: Option<Context>,
        name: String,
    ) -> Result<Option<outgoing_config::OutgoingEmailConfigToken>> {
        let configs = get_email_configs();
        match configs.get(&name) {
            // The returned token does not HAVE to be the name, but for simplicity it can be
            Some(config) => Ok(Some(config.name.clone())),
            None => {
                warn!(name, "missing email configuration");
                Ok(None)
            }
        }
    }
}

/// Implement the required interfaces for outgoing email sending
impl outgoing_sender::Handler<Option<Context>> for OutgoingEmailProvider {
    async fn send_email(
        &self,
        _ctx: Option<Context>,
        cfg_token: outgoing_sender::OutgoingEmailConfigToken,
        msg: outgoing_sender::OutgoingEmail,
    ) -> Result<Result<(), outgoing_sender::SendEmailError>> {
        let configs = get_email_configs();
        let config = match configs.get(&cfg_token) {
            // The returned token does not HAVE to be the name, but for simplicity it can be
            Some(config) => config,
            None => {
                return Ok(Err(outgoing_sender::SendEmailError::NoSuchConfig(format!(
                    "no config matched token [{cfg_token}]"
                ))));
            }
        };

        // If we don't have SMTP config we can quit early, only SMTP is supported
        let smtp_config = match &config.smtp {
            Some(cfg) => cfg,
            None => {
                return Ok(Err(outgoing_sender::SendEmailError::UnusableConfig(
                "configuration does not contain SMTP information, only SMTP is currently supported".into()
            )));
            }
        };

        let mut email_builder = lettre::Message::builder();

        // Set sender
        let sender: Mailbox = match msg.sender.parse() {
            Ok(m) => m,
            Err(e) => {
                error!(error = ?e, "failed to parse sender");
                return Ok(Err(outgoing_sender::SendEmailError::InvalidOutgoingEmail(
                    format!("failed to parse sender [{}]: {e}", msg.sender),
                )));
            }
        };
        email_builder = email_builder.from(sender.clone()).reply_to(sender);

        // Add in all recipients
        for r in msg.recipients {
            email_builder = email_builder.to(match r.parse() {
                Ok(m) => m,
                Err(e) => {
                    error!(error = ?e, "filed to parse recipient");
                    return Ok(Err(outgoing_sender::SendEmailError::InvalidOutgoingEmail(
                        format!("failed to parse recipient [{r}]",),
                    )));
                }
            });
        }

        // Set subject
        email_builder = email_builder.subject(msg.subject);

        // Build email message
        let email = if let Some(text) = msg.text {
            email_builder
                .header(ContentType::TEXT_PLAIN)
                .body(text)
                .map_err(|e| {
                    outgoing_sender::SendEmailError::InvalidOutgoingEmail(format!(
                        "failed to build email TEXT body: {e}"
                    ))
                })?
        } else if let Some(html) = msg.html {
            email_builder
                .header(ContentType::TEXT_HTML)
                .body(html)
                .map_err(|e| {
                    outgoing_sender::SendEmailError::InvalidOutgoingEmail(format!(
                        "failed to build email HTML body: {e}"
                    ))
                })?
        } else {
            return Ok(Err(outgoing_sender::SendEmailError::InvalidOutgoingEmail(
                "missing both text and HTML content types".into(),
            )));
        };

        // Open the SMTP connection
        let mut transport_builder =
            match AsyncSmtpTransport::<Tokio1Executor>::from_url(smtp_config.url.as_ref()) {
                Ok(t) => t,
                Err(e) => {
                    return Ok(Err(outgoing_sender::SendEmailError::Unexpected(format!(
                        "failed to build transport: {e}"
                    ))));
                }
            };

        // Add SMTP config auth if necessary
        if let Some(auth) = &smtp_config.auth {
            transport_builder = transport_builder.credentials(SmtpCredentials::new(
                auth.username.clone(),
                auth.password.clone(),
            ))
        }

        let transport = transport_builder.build();

        // Send the email
        match transport.send(email).await {
            Ok(_) => {
                debug!("Email sent successfully!");
            }
            Err(e) => {
                error!(error = ?e, "failed to send email");
            }
        }

        Ok(Ok(()))
    }
}
